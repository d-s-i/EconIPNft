{
  "language": "Solidity",
  "sources": {
    "contracts/Accounting.sol": {
      "content": "//SPDLicensIdentifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\nimport \"./EconNFTERC721.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/// @title Accounting contract for Economics Design.\r\n/// @notice Helps the company to know who bought how much books and when.\r\ncontract Accounting {\r\n\r\n    // owner of the contract.\r\n    address public owner;\r\n\r\n    uint256 public totalNumberOfBooksSold;\r\n    // Orders must be more than one per order.\r\n    uint256 public booksPerOrder;\r\n    // The price of one book.\r\n    uint256 public bookPrice;\r\n\r\n    // Accounting of number of books bought per address.\r\n    mapping(address => uint256) public numberOfBooksBought;\r\n\r\n    // The EconNFT contract.\r\n    EconNFTERC721 public econNFT;\r\n    // The USDC contract.\r\n    IERC20 public usdc;\r\n\r\n    /**\r\n        * @param _booksPerOrder the number of books you want per order (orders will need to be a multiple of this number).\r\n        * @param _bookPrice the number of USDC required to buy one book (/!\\ USDC have 6 decimals).\r\n        * @param _econNFTAddress address of the EconNFT token contract.\r\n        * @param _usdcAddress address of the USDC token contract.\r\n    **/ \r\n    constructor(uint256 _booksPerOrder, uint256 _bookPrice, address _econNFTAddress, address _usdcAddress) public {\r\n        booksPerOrder = _booksPerOrder;\r\n        bookPrice = _bookPrice;\r\n        econNFT = EconNFTERC721(_econNFTAddress);\r\n        usdc = IERC20(_usdcAddress);\r\n        // change this into Economics DEsign address\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /// @notice Restrict the function to the owner of the contract and revert otherwise.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"You are not the owner\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Function called by the owner of an EconNFT contract to order books to the company.\r\n    /// @dev Payements are handled in USDC.\r\n    function buyBooks(uint256 _numberOfBooks) external {\r\n        require(econNFT.balanceOf(msg.sender) > 0, \"You need to hold the property right token to buy and sell those books.\");\r\n        require(_numberOfBooks % booksPerOrder == 0, \"You can only buy a multiple of 20 books.\");\r\n\r\n        usdc.transferFrom(msg.sender, owner, _numberOfBooks * bookPrice);\r\n\r\n        numberOfBooksBought[msg.sender] += _numberOfBooks;\r\n        totalNumberOfBooksSold += _numberOfBooks;\r\n    }\r\n\r\n    /// @notice Set the number of books per order.\r\n    /// @dev Can only be called by the owner of the contract.\r\n    function setBooksPerOrder(uint256 _newBooksPerOrder) external onlyOwner {\r\n        booksPerOrder = _newBooksPerOrder;\r\n    }\r\n\r\n    /// @notice Set the price of one book.\r\n    /// @dev Can only be called by the owner of the contract.\r\n    function setBookPrice(uint256 _newBookPrice) external onlyOwner {\r\n        bookPrice = _newBookPrice;\r\n    }\r\n\r\n    /// @notice Set the owner of the contract.\r\n    /// @dev Can only be called by the current owner of the contract.\r\n    function setOwner(address _newOwner) external onlyOwner {\r\n        owner = _newOwner;\r\n    }\r\n}"
    },
    "contracts/EconNFTERC721.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\nimport { ERC721 } from \"./ERC721.sol\";\r\nimport \"./interfaces/IEconNFTERC721.sol\";\r\nimport \"base64-sol/base64.sol\";\r\n\r\n/// @title Economics Design Property Right NFT.\r\n/// @notice Contract used to verify the ownership of the Economics Design book property rights.\r\ncontract EconNFTERC721 is ERC721, IEconNFTERC721 {\r\n\r\n    // expiration timestamp of the NFT, date after the owner won't be able to buy books anymore. \r\n    struct Seed {\r\n        uint256 expirationTimestamp;\r\n    }\r\n\r\n    // Minter of the EconNFT. \r\n    address public minter;  \r\n\r\n    // Id currently auctionned.\r\n    uint256 private _currentEconNFTId;\r\n\r\n    bool public isMinterLocked;\r\n\r\n    // Contain information about the NFT that are set when its first minted.\r\n    mapping(uint256 => Seed) public seeds;\r\n\r\n    // Expiration timestamp currently associated with each EconNFT.\r\n    uint256 public currentExpirationTimestamp;\r\n\r\n    // Number of epoch passed, used for the auctionHouse\r\n    uint256 public numberOfPeriodPassed;\r\n\r\n    // Constant used to translate a timestamp into a date for tokenURI().\r\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    // Constant used to translate a timestamp into a date for tokenURI() as timestamps start from 01/01/1970.\r\n    int constant OFFSET19700101 = 2440588;\r\n\r\n    // Variables used to make the JPEG image.\r\n    uint256 public maxNumberOfPath;\r\n    uint256 public maxNumberOfPathCommands;\r\n    uint256 public size;\r\n    string[] public pathCommands;\r\n    string[] public colors;\r\n\r\n    /// @param _totalSupply maximum number of NFT that is going to be minted.\r\n    /// @param _expirationTimestamp the date where the EconNFT will expire (timestamp in seconds).\r\n    /// @dev Variables used to make the JPEG are set in order to construct an SVG later on. \r\n    constructor(uint256 _totalSupply, uint256 _expirationTimestamp) ERC721(\"Econteric IP\", \"ECIP\") public {\r\n        isMinterLocked = false;\r\n        _currentEconNFTId = 0;\r\n        numberOfPeriodPassed = 0;\r\n        currentExpirationTimestamp = _expirationTimestamp;\r\n\r\n        maxNumberOfPath = 10;\r\n        maxNumberOfPathCommands = 5;\r\n        size = 500;\r\n        pathCommands = [\"M\", \"L\"];\r\n        colors = [\"red\", \"blue\", \"green\", \"yellow\", \"black\", \"white\"];\r\n    }\r\n\r\n    /// @notice Restrict a function only when minter is not locked (i.e. isMinterLocked == false).\r\n    modifier whenMinterNotLocked() {\r\n        require(!isMinterLocked, \"EconNFT: Minter is locked\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Restrict a function to be called only by the minter address.\r\n    modifier onlyMinter() {\r\n        require(msg.sender == minter, \"EconNFT: Sender is not the minter\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Mint a new NFT.\r\n    /// @return Return the id of the minted NFT.\r\n    /// @dev Create a new NFT and send it to the minter.\r\n    function mint() public onlyMinter returns (uint256) {\r\n        return _mintTo(minter, _currentEconNFTId++);\r\n    }\r\n\r\n    /// @notice Call the ERC721 `_burn()` function which burn an NFT and sends it to the address(0).\r\n    /// @param econNFTId the id of the NFT you want to burn.\r\n    function burn(uint256 econNFTId) public onlyMinter {\r\n        _burn(econNFTId);\r\n    }\r\n\r\n    /// @notice Mint an property right NFT.\r\n    /// @param to the address to send to the minted NFT.\r\n    /// @param econNFTId the id of the NFT to mint.\r\n    function _mintTo(address to, uint256 econNFTId) internal returns (uint256) {\r\n        seeds[econNFTId] = Seed({\r\n            expirationTimestamp: currentExpirationTimestamp\r\n        });\r\n        _mint(to, econNFTId);\r\n\r\n        return econNFTId;\r\n    }\r\n\r\n    /// @notice Contain all the informations needed for read this NFT informations.\r\n    /// @param tokenId the id of the token you would like to read information from.\r\n    /// @return data a 64 based encoded string containing a json object with all the informations.\r\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\r\n        uint256 year;\r\n        uint256 month;\r\n        uint256 day;\r\n        (year, month, day) = timestampToDate(seeds[tokenId].expirationTimestamp); \r\n        uint256 randomNumber = block.timestamp / block.number;\r\n        string memory svg = generateSVG(randomNumber);\r\n        string memory imageURI = svgToImageURI(svg);\r\n        string memory json = Base64.encode(bytes(abi.encodePacked(\r\n            '{ \"name\": \"Economics Design Book\", ', \r\n            '\"description\": \"Economics and Math of Token Engineering and DeFi\"', \r\n            ', \"expirationDate\": \"',\r\n            uint2str(day),\r\n            '/',\r\n            uint2str(month),\r\n            '/',\r\n            uint2str(year),\r\n            '\", \"image\": \"',\r\n            imageURI,\r\n            '\" }'\r\n        )));\r\n\r\n        string memory data = string(abi.encodePacked('data:application/json;base64,', json));\r\n        return data;\r\n    }\r\n\r\n    /// @notice Transform a uint type into a string type. Used to encode tokenURI().\r\n    /// @param _i the uint to encode into string.\r\n    /// @return _uintAsString the same number but in a string format.\r\n    /// @dev Function taken from https://github.com/provable-things/ethereum-api/blob/master/provableAPI_0.6.sol\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    /// @notice Takes a timestamp in seconds and convert it into a human readable date.\r\n    /// @param timestamp the timestamp you want to convert.\r\n    /// @return year the year from your timestamp.\r\n    /// @return month the month from your timestamp (between 1 and 12).\r\n    /// @return day the day from your timestamp (between 1 and 31).\r\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n\r\n    /// @notice Calculate year/month/day from the number of days _days since 1970/01/01.\r\n    /// @param _days the number of day between the timestamp you can to convert into a date and 01/01/1970.\r\n    /// @return year the year from your timestamp.\r\n    /// @return month the month from your timestamp (between 1 and 12).\r\n    /// @return day the day from your timestamp (between 1 and 31).\r\n    /// @dev Function taken from https://etherscan.io/address/0x78f96b2d5f717fa9ad416957b79d825cc4cce69d#code.\r\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\r\n        int __days = int(_days);\r\n\r\n        int L = __days + 68569 + OFFSET19700101;\r\n        int N = 4 * L / 146097;\r\n        L = L - (146097 * N + 3) / 4;\r\n        int _year = 4000 * (L + 1) / 1461001;\r\n        L = L - 1461 * _year / 4 + 31;\r\n        int _month = 80 * L / 2447;\r\n        int _day = L - 2447 * _month / 80;\r\n        L = _month / 11;\r\n        _month = _month + 2 - 12 * L;\r\n        _year = 100 * (N - 49) + _year + L;\r\n\r\n        year = uint(_year);\r\n        month = uint(_month);\r\n        day = uint(_day);\r\n    }\r\n\r\n    /// @notice Generate a full SVG component.\r\n    /// @param _randomNumber is a random number used to construct the SVG (the more random the better).\r\n    /// @return finalSvg the full SVG component readable by a browser.\r\n    /// @dev The random number is used to print random lines and random colors on the final SVG.\r\n    function generateSVG(uint256 _randomNumber) public view returns(string memory finalSvg) {\r\n        uint256 numberOfPath = (_randomNumber % maxNumberOfPath) + 1;\r\n        finalSvg = string(abi.encodePacked('<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"', uint2str(size), '\" width=\"', uint2str(size), '\">'));\r\n        for(uint i = 0; i < numberOfPath; i++) {\r\n            uint256 newRNG = uint256(keccak256(abi.encode(_randomNumber, i)));\r\n            string memory pathSvg = generatePath(newRNG);\r\n            finalSvg = string(abi.encodePacked(finalSvg, pathSvg));\r\n        }\r\n        finalSvg = string(abi.encodePacked(finalSvg, \"</svg>\"));\r\n    }\r\n\r\n    /// @notice Generate different paths that creates the SVG lines.\r\n    /// @param _randomNumber is a random number from the `generatePath()` function.\r\n    /// @return pathSvg a string containing all SVG instructions.\r\n    /// @dev Function called by the `generateSVG()` function.\r\n    function generatePath(uint256 _randomNumber) public view returns(string memory pathSvg) {\r\n        uint256 numberOfPathCommands = (_randomNumber % maxNumberOfPathCommands) + 1;\r\n        pathSvg = '<path d=\"';\r\n        for(uint i = 0; i < numberOfPathCommands; i++) {\r\n            uint256 newRNG = uint256(keccak256(abi.encode(_randomNumber, size + i)));\r\n            string memory pathCommand = generatePathCommand(newRNG);\r\n            pathSvg = string(abi.encodePacked(pathSvg, pathCommand));\r\n        }\r\n        string memory color = colors[_randomNumber % colors.length];\r\n        pathSvg = string(abi.encodePacked(pathSvg, '\" fill=\"transparent\" stroke=\"', color, '\"/>'));\r\n    }\r\n\r\n    /// @notice Generate the paths to create the SVG.\r\n    /// @param _randomNumber is a random number from the `generatePath()` function.\r\n    /// @return pathCommand a string containing the paths to create the SVG.\r\n    /// @dev Called by the `generatePath()` function.\r\n    function generatePathCommand(uint256 _randomNumber) public view returns(string memory pathCommand) {\r\n        pathCommand = pathCommands[_randomNumber % pathCommands.length];\r\n        uint256 parameterOne = uint256(keccak256(abi.encode(_randomNumber, size * 2))) % size;\r\n        uint256 parameterTwo = uint256(keccak256(abi.encode(_randomNumber, size * 2 + 1))) % size;\r\n        pathCommand = string(abi.encodePacked(pathCommand, \" \", uint2str(parameterOne), \" \", uint2str(parameterTwo), \" \"));\r\n    }\r\n\r\n    /// @notice Takes a SVG and encode it while still keeping it readable by a browser.\r\n    /// @param _svg is the SVG component.\r\n    /// @return imageURI a string readable by the browser which will display the SVG.\r\n    function svgToImageURI(string memory _svg) public pure returns(string memory) {\r\n        string memory baseURL = \"data:image/svg+xml;base64,\";\r\n        string memory svgBase64Encoded = Base64.encode(bytes(string(abi.encodePacked(_svg))));\r\n        string memory imageURI = string(abi.encodePacked(baseURL, svgBase64Encoded));\r\n        return imageURI;\r\n    }\r\n\r\n    /// @notice Change the minter address.\r\n    /// @param _minter The new minter address.\r\n    function setMinter(address _minter) external onlyOwner whenMinterNotLocked {\r\n        minter = _minter;\r\n    }\r\n\r\n    /// @notice Lock the minter from calling certain functions.\r\n    function lockMinter() external onlyOwner whenMinterNotLocked {\r\n        isMinterLocked = true;\r\n    }\r\n\r\n    /// @notice Change the expiration timestamp of the future NFTs about to get minted.\r\n    /// @param _newExpirationTimestamp the new timestamp.\r\n    function setCurrentExpirationTimestamp(uint256 _newExpirationTimestamp) external override onlyOwner {\r\n        currentExpirationTimestamp = _newExpirationTimestamp;\r\n        numberOfPeriodPassed++;\r\n    }\r\n\r\n    /// @notice Used mainly for the auction house.\r\n    function getNumberOfPeriodPassed() public view override returns(uint256) {\r\n        return numberOfPeriodPassed;\r\n    }\r\n\r\n    /// @notice Used mainly for the auction house.\r\n    function getCurrentExpirationTimestamp() public view override returns(uint256) {\r\n        return currentExpirationTimestamp;\r\n    }\r\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\r\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\r\n * {ERC721Enumerable}.\r\n */\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, Ownable {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    // Token name\r\n    string private _name;\r\n\r\n    // Token symbol\r\n    string private _symbol;\r\n\r\n    // Mapping from token ID to owner address\r\n    mapping(uint256 => address) private _owners;\r\n\r\n    // Mapping owner address to token count\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    address public econAuctionHouse;\r\n\r\n    /**\r\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) Ownable() {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function setAuctionHouse(address newAuctionHouse) public onlyOwner {\r\n        econAuctionHouse = newAuctionHouse;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return\r\n            interfaceId == type(IERC721).interfaceId ||\r\n            interfaceId == type(IERC721Metadata).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-balanceOf}.\r\n     */\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-ownerOf}.\r\n     */\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = _owners[tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-name}.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-symbol}.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n\r\n    /**\r\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n     * by default, can be overriden in child contracts.\r\n     */\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return \"lol\";\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-approve}.\r\n     */\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n        require(\r\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n            \"ERC721: approve caller is not owner nor approved for all\"\r\n        );\r\n\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-getApproved}.\r\n     */\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(operator != _msgSender(), \"ERC721: approve to caller\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-isApprovedForAll}.\r\n     */\r\n\r\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\r\n        if(operator == econAuctionHouse) {\r\n            return true;\r\n        }\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-transferFrom}.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        //solhint-disable-next-line max-line-length\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n        _transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) public virtual override {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) public virtual override {\r\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n        _safeTransfer(from, to, tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n     *\r\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _transfer(from, to, tokenId);\r\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `tokenId` exists.\r\n     *\r\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n     *\r\n     * Tokens start existing when they are minted (`_mint`),\r\n     * and stop existing when they are burned (`_burn`).\r\n     */\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n    }\r\n\r\n    /**\r\n     * @dev Safely mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n     */\r\n    function _safeMint(\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(\r\n            _checkOnERC721Received(address(0), to, tokenId, _data),\r\n            \"ERC721: transfer to non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Mints `tokenId` and transfers it to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must not exist.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n        _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(address(0), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `tokenId`.\r\n     * The approval is cleared when the token is burned.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _burn(uint256 tokenId) internal virtual {\r\n\r\n        address owner = ERC721.ownerOf(tokenId);\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n        // Clear approvals\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[owner] -= 1;\r\n        delete _owners[tokenId];\r\n\r\n        emit Transfer(owner, address(0), tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` from `from` to `to`.\r\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {\r\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\r\n        require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, tokenId);\r\n\r\n        // Clear approvals from the previous owner\r\n        _approve(address(0), tokenId);\r\n\r\n        _balances[from] -= 1;\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n\r\n        emit Transfer(from, to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `to` to operate on `tokenId`\r\n     *\r\n     * Emits a {Approval} event.\r\n     */\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n     * The call is not executed if the target address is not a contract.\r\n     *\r\n     * @param from address representing the previous owner of the given token ID\r\n     * @param to target address that will receive the tokens\r\n     * @param tokenId uint256 ID of the token to be transferred\r\n     * @param _data bytes optional data to send along with the call\r\n     * @return bool whether the call correctly returned the expected magic value\r\n     */\r\n    function _checkOnERC721Received(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes memory _data\r\n    ) private returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual {}\r\n}\r\n"
    },
    "contracts/interfaces/IEconNFTERC721.sol": {
      "content": "interface IEconNFTERC721 {\r\n    function setCurrentExpirationTimestamp(uint256 _newExpirationTimestamp) external virtual;\r\n    function getNumberOfPeriodPassed() external view virtual returns(uint256);\r\n    function getCurrentExpirationTimestamp() external view virtual returns(uint256);\r\n}"
    },
    "base64-sol/base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/test/USDC.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract USDC is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _totalSupply = 10000000000 * 10**6;\r\n        _balances[msg.sender] = _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 6;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``sender``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\r\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\r\n        unchecked {\r\n            _approve(sender, _msgSender(), currentAllowance - amount);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n\r\n        uint256 senderBalance = _balances[sender];\r\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[sender] = senderBalance - amount;\r\n        }\r\n        _balances[recipient] += amount;\r\n\r\n        emit Transfer(sender, recipient, amount);\r\n\r\n        _afterTokenTransfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n"
    },
    "contracts/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./interfaces/IERC1155.sol\";\r\nimport \"./interfaces/IERC1155Receiver.sol\";\r\nimport \"./extensions/IERC1155MetadataURI.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\r\n\r\n/**\r\n * @dev Implementation of the basic standard multi-token.\r\n * See https://eips.ethereum.org/EIPS/eip-1155\r\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\r\n *\r\n * _Available since v3.1._\r\n */\r\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\r\n    using Address for address;\r\n\r\n    // Mapping from token ID to account balances\r\n    mapping(uint256 => mapping(address => uint256)) private _balances;\r\n\r\n    // Mapping from account to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\r\n    string private _uri;\r\n\r\n    address public econAuctionHouse;\r\n\r\n    address public ERC1155Owner;\r\n\r\n    /**\r\n     * @dev See {_setURI}.\r\n     */\r\n    constructor(string memory uri_) {\r\n        _setURI(uri_);\r\n        ERC1155Owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return\r\n            interfaceId == type(IERC1155).interfaceId ||\r\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155MetadataURI-uri}.\r\n     *\r\n     * This implementation returns the same URI for *all* token types. It relies\r\n     * on the token type ID substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * Clients calling this function must replace the `\\{id\\}` substring with the\r\n     * actual token type ID.\r\n     */\r\n    function uri(uint256) public view virtual override returns (string memory) {\r\n        return _uri;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\r\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\r\n        return _balances[id][account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-balanceOfBatch}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\r\n        public\r\n        view\r\n        virtual\r\n        override\r\n        returns (uint256[] memory)\r\n    {\r\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](accounts.length);\r\n\r\n        for (uint256 i = 0; i < accounts.length; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-setApprovalForAll}.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        require(_msgSender() != operator, \"ERC1155: setting approval status for self\");\r\n\r\n        _operatorApprovals[_msgSender()][operator] = approved;\r\n        emit ApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-isApprovedForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\r\n        if(operator == econAuctionHouse) {\r\n            return true;\r\n        }\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeTransferFrom}.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n        _safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC1155-safeBatchTransferFrom}.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual override {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: transfer caller is not owner nor approved\"\r\n        );\r\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n\r\n        uint256 fromBalance = _balances[id][from];\r\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n        unchecked {\r\n            _balances[id][from] = fromBalance - amount;\r\n        }\r\n        _balances[id][to] += amount;\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 fromBalance = _balances[id][from];\r\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\r\n            unchecked {\r\n                _balances[id][from] = fromBalance - amount;\r\n            }\r\n            _balances[id][to] += amount;\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new URI for all token types, by relying on the token type ID\r\n     * substitution mechanism\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\r\n     *\r\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\r\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\r\n     * clients with the token type ID.\r\n     *\r\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\r\n     * interpreted by clients as\r\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\r\n     * for token type ID 0x4cce0.\r\n     *\r\n     * See {uri}.\r\n     *\r\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\r\n     * this function emits no events.\r\n     */\r\n    function _setURI(string memory newuri) internal virtual {\r\n        _uri = newuri;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _mint(\r\n        address account,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(account != address(0), \"ERC1155: mint to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\r\n\r\n        _balances[id][account] += amount;\r\n        emit TransferSingle(operator, address(0), account, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function _mintBatch(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC1155: mint to the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            _balances[ids[i]][to] += amounts[i];\r\n        }\r\n\r\n        emit TransferBatch(operator, address(0), to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens of token type `id` from `account`\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens of token type `id`.\r\n     */\r\n    function _burn(\r\n        address account,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(account != address(0), \"ERC1155: burn from the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\r\n\r\n        uint256 accountBalance = _balances[id][account];\r\n        require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[id][account] = accountBalance - amount;\r\n        }\r\n\r\n        emit TransferSingle(operator, account, address(0), id, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     */\r\n    function _burnBatch(\r\n        address account,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts\r\n    ) internal virtual {\r\n        require(account != address(0), \"ERC1155: burn from the zero address\");\r\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            uint256 accountBalance = _balances[id][account];\r\n            require(accountBalance >= amount, \"ERC1155: burn amount exceeds balance\");\r\n            unchecked {\r\n                _balances[id][account] = accountBalance - amount;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(operator, account, address(0), ids, amounts);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning, as well as batched variants.\r\n     *\r\n     * The same hook is called on both single and batched variants. For single\r\n     * transfers, the length of the `id` and `amount` arrays will be 1.\r\n     *\r\n     * Calling conditions (for each `id` and `amount` pair):\r\n     *\r\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * of token type `id` will be  transferred to `to`.\r\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\r\n     * for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\r\n     * will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     * - `ids` and `amounts` have the same, non-zero length.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual {}\r\n\r\n    function _doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) private {\r\n        if (to.isContract()) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\r\n                bytes4 response\r\n            ) {\r\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\r\n        uint256[] memory array = new uint256[](1);\r\n        array[0] = element;\r\n\r\n        return array;\r\n    }\r\n\r\n    modifier onlyERC1155Owner() {\r\n        require(msg.sender == ERC1155Owner);\r\n        _;\r\n    }\r\n\r\n    function setEconAuctionHouse(address _econAuctionHouse) public onlyERC1155Owner {\r\n        econAuctionHouse = _econAuctionHouse;\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\r\npragma solidity ^0.8.0;\r\n\r\n/// @title ERC-1155 Multi Token Standard\r\n/// @dev ee https://eips.ethereum.org/EIPS/eip-1155\r\n///  The ERC-165 identifier for this interface is 0xd9b67a26.\r\ninterface IERC1155 /* is ERC165 */ {\r\n    /**\r\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).\r\n        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\r\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\r\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\r\n        The `_id` argument MUST be the token type being transferred.\r\n        The `_value` argument MUST be the number of tokens the holder balance is decreased by and match what the recipient balance is increased by.\r\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\r\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).        \r\n    */\r\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\r\n\r\n    /**\r\n        @dev Either `TransferSingle` or `TransferBatch` MUST emit when tokens are transferred, including zero value transfers as well as minting or burning (see \"Safe Transfer Rules\" section of the standard).      \r\n        The `_operator` argument MUST be the address of an account/contract that is approved to make the transfer (SHOULD be msg.sender).\r\n        The `_from` argument MUST be the address of the holder whose balance is decreased.\r\n        The `_to` argument MUST be the address of the recipient whose balance is increased.\r\n        The `_ids` argument MUST be the list of tokens being transferred.\r\n        The `_values` argument MUST be the list of number of tokens (matching the list and order of tokens specified in _ids) the holder balance is decreased by and match what the recipient balance is increased by.\r\n        When minting/creating tokens, the `_from` argument MUST be set to `0x0` (i.e. zero address).\r\n        When burning/destroying tokens, the `_to` argument MUST be set to `0x0` (i.e. zero address).                \r\n    */\r\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\r\n\r\n    /**\r\n        @dev MUST emit when approval for a second party/operator address to manage all tokens for an owner address is enabled or disabled (absence of an event assumes disabled).        \r\n    */\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /**\r\n        @dev MUST emit when the URI is updated for a token ID.\r\n        URIs are defined in RFC 3986.\r\n        The URI MUST point to a JSON file that conforms to the \"ERC-1155 Metadata URI JSON Schema\".\r\n    */\r\n    event URI(string _value, uint256 indexed _id);\r\n\r\n    /**\r\n        @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        MUST revert if `_to` is the zero address.\r\n        MUST revert if balance of holder for token `_id` is lower than the `_value` sent.\r\n        MUST revert on any other error.\r\n        MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard).\r\n        After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).        \r\n        @param _from    Source address\r\n        @param _to      Target address\r\n        @param _id      ID of the token type\r\n        @param _value   Transfer amount\r\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to`\r\n    */\r\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\r\n\r\n    /**\r\n        @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call).\r\n        @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard).\r\n        MUST revert if `_to` is the zero address.\r\n        MUST revert if length of `_ids` is not the same as length of `_values`.\r\n        MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient.\r\n        MUST revert on any other error.        \r\n        MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard).\r\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\r\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard).                      \r\n        @param _from    Source address\r\n        @param _to      Target address\r\n        @param _ids     IDs of each token type (order and length must match _values array)\r\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\r\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\r\n    */\r\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\r\n\r\n    /**\r\n        @notice Get the balance of an account's tokens.\r\n        @param _owner  The address of the token holder\r\n        @param _id     ID of the token\r\n        @return        The _owner's balance of the token type requested\r\n     */\r\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\r\n\r\n    /**\r\n        @notice Get the balance of multiple account/token pairs\r\n        @param _owners The addresses of the token holders\r\n        @param _ids    ID of the tokens\r\n        @return        The _owner's balance of the token types requested (i.e. balance for each (owner, id) pair)\r\n     */\r\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\r\n\r\n    /**\r\n        @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens.\r\n        @dev MUST emit the ApprovalForAll event on success.\r\n        @param _operator  Address to add to the set of authorized operators\r\n        @param _approved  True if the operator is approved, false to revoke approval\r\n    */\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /**\r\n        @notice Queries the approval status of an operator for a given owner.\r\n        @param _owner     The owner of the tokens\r\n        @param _operator  Address of authorized operator\r\n        @return           True if the operator is approved, false if not\r\n    */\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n"
    },
    "contracts/interfaces/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n        @dev Handles the receipt of a single ERC1155 token type. This function is\r\n        called at the end of a `safeTransferFrom` after the balance has been updated.\r\n        To accept the transfer, this must return\r\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n        (i.e. 0xf23a6e61, or its own function selector).\r\n        @param operator The address which initiated the transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param id The ID of the token being transferred\r\n        @param value The amount of tokens being transferred\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n        is called at the end of a `safeBatchTransferFrom` after the balances have\r\n        been updated. To accept the transfer(s), this must return\r\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n        (i.e. 0xbc197c81, or its own function selector).\r\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param from The address which previously owned the token\r\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n        @param data Additional data with no specified format\r\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n    */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n"
    },
    "contracts/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interfaces/IERC1155.sol\";\r\n\r\n/**\r\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\r\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155MetadataURI is IERC1155 {\r\n    /**\r\n     * @dev Returns the URI for token type `id`.\r\n     *\r\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\r\n     * clients with the actual token type ID.\r\n     */\r\n    function uri(uint256 id) external view returns (string memory);\r\n}\r\n"
    },
    "contracts/interfaces/IEconNFT.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n\r\ninterface IEconNFT is IERC721 {\r\n    function mint() external returns (uint256);\r\n\r\n    function burn(uint256 econNFTId) external;\r\n}"
    },
    "contracts/EconNFT.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.6;\r\n\r\nimport { ERC1155 } from \"./ERC1155.sol\";\r\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"base64-sol/base64.sol\";\r\n\r\n/// @title Economics Design Property Right NFT.\r\n/// @notice Contract used to verify the ownership of the Economics Design book property rights.\r\ncontract EconNFT is ERC1155, Ownable {\r\n\r\n    address public minter;\r\n    \r\n    constructor(address _minter) ERC1155(\"https://www.econteric.com/\") public {\r\n        minter = _minter;\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(msg.sender == minter);\r\n        _;\r\n    }\r\n\r\n    function mint(address _to, uint256 _tokenId, uint256 _amount) external onlyMinter {\r\n        _mint(_to, _tokenId, _amount, \"\");\r\n    }\r\n\r\n    // need a way to set tokenURIs for each tokenId\r\n\r\n    function setMinter(address _newMinter) public onlyOwner {\r\n        minter = _newMinter;\r\n    }\r\n}"
    },
    "contracts/EconAuctionHouse.sol": {
      "content": "pragma solidity ^0.8.0;\r\n\r\nimport \"./interfaces/IERC20.sol\";\r\nimport \"./interfaces/IERC721.sol\";\r\nimport \"./interfaces/IERC721TokenReceiver.sol\";\r\nimport \"./interfaces/IERC1155.sol\";\r\nimport \"./interfaces/IERC1155TokenReceiver.sol\";\r\nimport \"./interfaces/IEconNFTERC721.sol\";\r\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\ncontract EconAuctionHouse is Ownable {\r\n\r\n    //Event emitted when an auction is being setup\r\n    event Auction_Initialized(\r\n        uint256 indexed _auctionID,\r\n        uint256 indexed _tokenID,\r\n        uint256 indexed _tokenIndex,\r\n        address _contractAddress,\r\n        bytes4 _tokenKind\r\n    );\r\n\r\n    //Event emitted when the start time of an auction changes (due to admin interaction )\r\n    event Auction_StartTimeUpdated(uint256 indexed _auctionID, uint256 _startTime);\r\n\r\n    //Event emitted when the end time of an auction changes (be it due to admin interaction or bid at the end)\r\n    event Auction_EndTimeUpdated(uint256 indexed _auctionID, uint256 _endTime);\r\n\r\n    //Event emitted when a Bid is placed\r\n    event Auction_BidPlaced(uint256 indexed _auctionID, address indexed _bidder, uint256 _bidAmount);\r\n\r\n    //Event emitted when a bid is removed (due to a new bid displacing it)\r\n    event Auction_BidRemoved(uint256 indexed _auctionID, address indexed _bidder, uint256 _bidAmount);\r\n\r\n    //Event emitted when incentives are paid (due to a new bid rewarding the _earner bid)\r\n    event Auction_IncentivePaid(uint256 indexed _auctionID, address indexed _earner, uint256 _incentiveAmount);\r\n\r\n    event Contract_BiddingAllowed(address indexed _contract, bool _biddingAllowed);\r\n\r\n    event Auction_ItemClaimed(uint256 indexed _auctionID);\r\n\r\n    struct TokenRepresentation {\r\n        address contractAddress; // The contract address\r\n        uint256 tokenId; // The ID of the token on the contract\r\n        bytes4 tokenKind; // The ERC name of the token implementation bytes4(keccak256(\"ERC721\")) or bytes4(keccak256(\"ERC1155\"))\r\n    }\r\n\r\n    struct Auction {\r\n        address owner;\r\n        address highestBidder;\r\n        uint256 highestBid;\r\n        uint256 secondHighestBid;\r\n        uint256 auctionDebt;\r\n        uint256 dueIncentives;\r\n        address contractAddress;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 hammerTimeDuration;\r\n        uint256 bidDecimals;\r\n        uint256 stepMin;\r\n        uint256 incMin;\r\n        uint256 incMax;\r\n        uint256 bidMultiplier;\r\n        bool biddingAllowed;\r\n    }\r\n\r\n    struct Collection {\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        uint256 hammerTimeDuration;\r\n        uint256 bidDecimals;\r\n        uint256 stepMin;\r\n        uint256 incMin; // minimal earned incentives\r\n        uint256 incMax; // maximal earned incentives\r\n        uint256 bidMultiplier; // bid incentive growth multiplier\r\n        bool biddingAllowed; // Allow to start/pause ongoing auctions\r\n    }\r\n\r\n    address internal daoTreasury;\r\n    // Contract address storing the ERC20 currency used in auctions\r\n    address internal erc20Currency;\r\n\r\n    // tokencontract => collections\r\n    mapping(address => Collection) internal collections; \r\n    // contractAddress => tokenId => TokenIndex => _auctionId\r\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) internal auctionMapping; \r\n    //_auctionId => auctions\r\n    mapping(uint256 => Auction) internal auctions; \r\n    //_auctionId => token_primaryKey\r\n    mapping(uint256 => TokenRepresentation) internal tokenMapping; \r\n    // Contract => TokenID => Amount being auctionned\r\n    mapping(address => mapping(uint256 => uint256)) internal erc1155TokensIndex; \r\n    //Contract => TokenID => Amount being auctionned\r\n    mapping(address => mapping(uint256 => uint256)) internal erc1155TokensUnderAuction; \r\n\r\n    mapping(uint256 => bool) internal auctionItemClaimed;\r\n\r\n\r\n    address public econNFT;\r\n\r\n    // store the previousOwner to give funds back for a Re-auction\r\n    mapping(uint256 => address) public previousOwnerForReAuction;\r\n\r\n    constructor(address _econNFT) Ownable() public {\r\n        econNFT = _econNFT;\r\n    }\r\n\r\n    /// @notice Register an auction contract default parameters for a GBM auction. To use to save gas\r\n    /// @param _contract The token contract the auctionned token belong to\r\n    function registerAnAuctionContract(\r\n        address _contract,\r\n        uint256 _startTime,\r\n        uint256 _endTime,\r\n        uint256 _hammerTimeDuration,\r\n        uint256 _bidDecimals,\r\n        uint256 _stepMin,\r\n        uint256 _incMin,\r\n        uint256 _incMax\r\n    ) public onlyOwner {\r\n        collections[_contract].startTime = _startTime;\r\n        collections[_contract].endTime = _endTime;\r\n        collections[_contract].hammerTimeDuration = _hammerTimeDuration;\r\n        collections[_contract].bidDecimals = _bidDecimals;\r\n        collections[_contract].stepMin = _stepMin;\r\n        collections[_contract].incMin = _incMin;\r\n        collections[_contract].incMax = _incMax;\r\n    }\r\n\r\n    /// @notice Register an auction token and emit the relevant AuctionInitialized & AuctionStartTimeUpdated events\r\n    /// Throw if the token owner is not the GBM smart contract/supply of auctionned 1155 token is insufficient\r\n    /// @param _tokenContract The token contract the auctionned token belong to\r\n    /// @param _tokenId The token ID of the token being auctionned\r\n    /// @param _tokenKind either bytes4(keccak256(\"ERC721\")) or bytes4(keccak256(\"ERC1155\"))\r\n    /// @param _useInitiator Set to `false` if you want to use the default value registered for the token contract (if wanting to reset to default,\r\n    /// use `true`)\r\n    function registerAnAuctionToken(\r\n        address _tokenContract,\r\n        uint256 _tokenId,\r\n        bytes4 _tokenKind,\r\n        bool _useInitiator\r\n    ) public onlyOwner {\r\n        modifyAnAuctionToken(_tokenContract, _tokenId, _tokenKind, _useInitiator, 0, false);\r\n    }\r\n\r\n    /// @notice Register an auction token and emit the relevant AuctionInitialized & AuctionStartTimeUpdated events\r\n    /// Throw if the token owner is not the GBM smart contract/supply of auctionned 1155 token is insufficient\r\n    /// @param _tokenContract The token contract the auctionned token belong to\r\n    /// @param _tokenId The token ID of the token being auctionned\r\n    /// @param _tokenKind either bytes4(keccak256(\"ERC721\")) or bytes4(keccak256(\"ERC1155\"))\r\n    /// @param _useInitiator Set to `false` if you want to use the default value registered for the token contract (if wanting to reset to default,\r\n    /// use `true`)\r\n    /// @param _1155Index Set to 0 if dealing with an ERC-721 or registering new 1155 test. otherwise, set to relevant index you want to reinitialize\r\n    /// @param _rewrite Set to true if you want to rewrite the data of an existing auction, false otherwise\r\n    function modifyAnAuctionToken(\r\n        address _tokenContract,\r\n        uint256 _tokenId,\r\n        bytes4 _tokenKind,\r\n        bool _useInitiator,\r\n        uint256 _1155Index,\r\n        bool _rewrite\r\n    ) internal {\r\n        if (!_rewrite) {\r\n            _1155Index = erc1155TokensIndex[_tokenContract][_tokenId]; //_1155Index was 0 if creating new auctions\r\n            require(auctionMapping[_tokenContract][_tokenId][_1155Index] == 0, \"The auction aleady exist for the specified token\");\r\n        } else {\r\n            require(auctionMapping[_tokenContract][_tokenId][_1155Index] != 0, \"The auction doesn't exist yet for the specified token\");\r\n        }\r\n\r\n        //Checking the kind of token being registered\r\n        require(\r\n            _tokenKind == bytes4(keccak256(\"ERC721\")) || _tokenKind == bytes4(keccak256(\"ERC1155\")),\r\n            \"registerAnAuctionToken: Only ERC1155 and ERC721 tokens are supported\"\r\n        );\r\n\r\n        //Building the auction object\r\n        TokenRepresentation memory newAuction;\r\n        newAuction.contractAddress = _tokenContract;\r\n        newAuction.tokenId = _tokenId;\r\n        newAuction.tokenKind = _tokenKind;\r\n\r\n        uint256 _auctionId;\r\n\r\n        if (_tokenKind == bytes4(keccak256(\"ERC721\"))) {\r\n            require(\r\n                msg.sender == Ownable(_tokenContract).owner() || address(this) == IERC721(_tokenContract).ownerOf(_tokenId),\r\n                \"registerAnAuctionToken: the specified ERC-721 token cannot be auctioned\"\r\n            );\r\n\r\n            _auctionId = uint256(keccak256(abi.encodePacked(_tokenContract, _tokenId, _tokenKind)));\r\n            auctionMapping[_tokenContract][_tokenId][0] = _auctionId;\r\n        } else {\r\n            require(\r\n                msg.sender == Ownable(_tokenContract).owner() ||\r\n                    erc1155TokensUnderAuction[_tokenContract][_tokenId] < IERC1155(_tokenContract).balanceOf(address(this), _tokenId),\r\n                \"registerAnAuctionToken:  the specified ERC-1155 token cannot be auctionned\"\r\n            );\r\n\r\n            require(\r\n                _1155Index <= erc1155TokensIndex[_tokenContract][_tokenId],\r\n                \"The specified _1155Index have not been reached yet for this token\"\r\n            );\r\n\r\n            _auctionId = uint256(keccak256(abi.encodePacked(_tokenContract, _tokenId, _tokenKind, _1155Index)));\r\n\r\n            if (!_rewrite) {\r\n                erc1155TokensIndex[_tokenContract][_tokenId] = erc1155TokensIndex[_tokenContract][_tokenId] + 1;\r\n                erc1155TokensUnderAuction[_tokenContract][_tokenId] = erc1155TokensUnderAuction[_tokenContract][_tokenId] + 1;\r\n            }\r\n\r\n            auctionMapping[_tokenContract][_tokenId][_1155Index] = _auctionId;\r\n        }\r\n\r\n        tokenMapping[_auctionId] = newAuction;\r\n\r\n        if (_useInitiator) {\r\n            auctions[_auctionId].owner = owner();\r\n            auctions[_auctionId].startTime = collections[_tokenContract].startTime;\r\n            auctions[_auctionId].endTime = collections[_tokenContract].endTime;\r\n            auctions[_auctionId].hammerTimeDuration = collections[_tokenContract].hammerTimeDuration;\r\n            auctions[_auctionId].bidDecimals = collections[_tokenContract].bidDecimals;\r\n            auctions[_auctionId].stepMin = collections[_tokenContract].stepMin;\r\n            auctions[_auctionId].incMin = collections[_tokenContract].incMin;\r\n            auctions[_auctionId].incMax = collections[_tokenContract].incMax;\r\n            auctions[_auctionId].bidMultiplier = collections[_tokenContract].bidMultiplier;\r\n        }\r\n\r\n        //Event emitted when an auction is being setup\r\n        emit Auction_Initialized(_auctionId, _tokenId, _1155Index, _tokenContract, _tokenKind);\r\n\r\n        //Event emitted when the start time of an auction changes (due to admin interaction )\r\n        emit Auction_StartTimeUpdated(_auctionId, getAuctionStartTime(_auctionId));\r\n    }\r\n\r\n    /// @notice Place a GBM bid for a GBM auction\r\n    /// @param _auctionId The auction you want to bid on\r\n    /// @param _bidAmount The amount of the ERC20 token the bid is made of. They should be withdrawable by this contract.\r\n    /// @param _highestBid The current higest bid. Throw if incorrect.\r\n    function bid(\r\n        uint256 _auctionId,\r\n        uint256 _bidAmount,\r\n        uint256 _highestBid\r\n    ) external {\r\n        require(collections[tokenMapping[_auctionId].contractAddress].biddingAllowed, \"bid: bidding is currently not allowed\");\r\n\r\n        require(_bidAmount > 1, \"bid: _bidAmount cannot be 0\");\r\n\r\n        require(_highestBid == auctions[_auctionId].highestBid, \"bid: current highest bid does not match the submitted transaction _highestBid\");\r\n\r\n        //An auction start time of 0 also indicate the auction has not been created at all\r\n\r\n        require(getAuctionStartTime(_auctionId) <= block.timestamp && getAuctionStartTime(_auctionId) != 0, \"bid: Auction has not started yet\");\r\n        require(getAuctionEndTime(_auctionId) >= block.timestamp, \"bid: Auction has already ended\");\r\n\r\n        require(_bidAmount > _highestBid, \"bid: _bidAmount must be higher than _highestBid\");\r\n\r\n        require(\r\n            // (_highestBid * (getAuctionBidDecimals(_auctionId)) + (getAuctionStepMin(_auctionId) / getAuctionBidDecimals(_auctionId))) >= _highestBid,\r\n            // \"bid: _bidAmount must meet the minimum bid\"\r\n\r\n            (_highestBid * (getAuctionBidDecimals(_auctionId) + getAuctionStepMin(_auctionId))) <= (_bidAmount * getAuctionBidDecimals(_auctionId)),\r\n            \"bid: _bidAmount must meet the minimum bid\"\r\n        );\r\n\r\n        //Transfer the money of the bidder to the GBM smart contract\r\n        IERC20(erc20Currency).transferFrom(msg.sender, address(this), _bidAmount);\r\n\r\n        //Extend the duration time of the auction if we are close to the end\r\n        if (getAuctionEndTime(_auctionId) < block.timestamp + getAuctionHammerTimeDuration(_auctionId)) {\r\n            auctions[_auctionId].endTime = block.timestamp + getAuctionHammerTimeDuration(_auctionId);\r\n            emit Auction_EndTimeUpdated(_auctionId, auctions[_auctionId].endTime);\r\n        }\r\n\r\n        // Saving incentives for later sending\r\n        uint256 duePay = auctions[_auctionId].dueIncentives;\r\n        address previousHighestBidder = auctions[_auctionId].highestBidder;\r\n        uint256 previousHighestBid = auctions[_auctionId].highestBid;\r\n\r\n        // Emitting the event sequence\r\n        if (previousHighestBidder != address(0)) {\r\n            emit Auction_BidRemoved(_auctionId, previousHighestBidder, previousHighestBid);\r\n        }\r\n\r\n        if (duePay != 0) {\r\n            auctions[_auctionId].auctionDebt = auctions[_auctionId].auctionDebt + duePay;\r\n            emit Auction_IncentivePaid(_auctionId, previousHighestBidder, duePay);\r\n        }\r\n\r\n        emit Auction_BidPlaced(_auctionId, msg.sender, _bidAmount);\r\n\r\n        // Calculating incentives for the new bidder\r\n        auctions[_auctionId].dueIncentives = calculateIncentives(_auctionId, _bidAmount);\r\n\r\n        //Setting the new bid/bidder as the highest bid/bidder\r\n        auctions[_auctionId].highestBidder = msg.sender;\r\n        auctions[_auctionId].secondHighestBid = auctions[_auctionId].highestBid;\r\n        auctions[_auctionId].highestBid = _bidAmount;\r\n\r\n        if ((previousHighestBid + duePay) != 0) {\r\n            //Refunding the previous bid as well as sending the incentives\r\n\r\n            //Added to prevent revert\r\n            IERC20(erc20Currency).approve(address(this), (previousHighestBid + duePay));\r\n\r\n            IERC20(erc20Currency).transferFrom(address(this), previousHighestBidder, (previousHighestBid + duePay));\r\n        }\r\n    }\r\n\r\n    /// @notice Attribute a token to the winner of the auction and distribute the proceeds to the owner of this contract.\r\n    /// throw if bidding is disabled or if the auction is not finished.\r\n    /// @param _auctionId The auctionId of the auction to complete\r\n    function claimForFirstTime(uint256 _auctionId) public {\r\n        require(\r\n            IEconNFTERC721(econNFT).getNumberOfPeriodPassed() == 0, \r\n            \"EconAuctionHouse : Period to claim for the first time has passed\"\r\n        );\r\n        address _contractAddress = tokenMapping[_auctionId].contractAddress;\r\n        uint256 _tid = tokenMapping[_auctionId].tokenId;\r\n\r\n        require(collections[_contractAddress].biddingAllowed, \"claim: Claiming is currently not allowed\");\r\n        require(getAuctionEndTime(_auctionId) < block.timestamp, \"claim: Auction has not yet ended\");\r\n        require(auctionItemClaimed[_auctionId] == false, \"claim: Item has already been claimed\");\r\n\r\n        //Prevents re-entrancy\r\n        auctionItemClaimed[_auctionId] = true;\r\n\r\n        uint256 _proceeds;\r\n        uint256 remainingFunds;\r\n        if(auctions[_auctionId].secondHighestBid == 0) {\r\n            _proceeds = auctions[_auctionId].highestBid - auctions[_auctionId].auctionDebt;\r\n        } else {\r\n            _proceeds = auctions[_auctionId].secondHighestBid - auctions[_auctionId].auctionDebt;\r\n            remainingFunds = auctions[_auctionId].highestBid - auctions[_auctionId].secondHighestBid;\r\n        }\r\n\r\n        // Added to prevent revert\r\n        IERC20(erc20Currency).approve(address(this), 2**256 - 1);\r\n\r\n        IERC20(erc20Currency).transferFrom(address(this), daoTreasury, _proceeds);\r\n\r\n        if(remainingFunds > 0) {\r\n            IERC20(erc20Currency).transferFrom(address(this), auctions[_auctionId].highestBidder, remainingFunds);\r\n        }\r\n\r\n        if (tokenMapping[_auctionId].tokenKind == bytes4(keccak256(\"ERC721\"))) {\r\n            //0x73ad2146\r\n            IERC721(_contractAddress).safeTransferFrom(address(this), auctions[_auctionId].highestBidder, _tid);\r\n        } else if (tokenMapping[_auctionId].tokenKind == bytes4(keccak256(\"ERC1155\"))) {\r\n            //0x973bb640\r\n            IERC1155(_contractAddress).safeTransferFrom(address(this), auctions[_auctionId].highestBidder, _tid, 1, \"\");\r\n            erc1155TokensUnderAuction[_contractAddress][_tid] = erc1155TokensUnderAuction[_contractAddress][_tid] - 1;\r\n        }\r\n\r\n        emit Auction_ItemClaimed(_auctionId);\r\n    }\r\n\r\n    /// @notice Attribute a token to the winner of the auction and distribute the proceeds to the owner of this contract.\r\n    /// throw if bidding is disabled or if the auction is not finished.\r\n    /// @param _auctionId The auctionId of the auction to complete\r\n    function claimAfterReAuctionned(uint256 _auctionId) public {\r\n        require(\r\n            IEconNFTERC721(econNFT).getNumberOfPeriodPassed() >= 1, \r\n            \"EconAuctionHouse: NFT hasn't been re-auctionned yet\"\r\n        );\r\n        address _contractAddress = tokenMapping[_auctionId].contractAddress;\r\n        uint256 _tid = tokenMapping[_auctionId].tokenId;\r\n\r\n        require(collections[_contractAddress].biddingAllowed, \"claim: Claiming is currently not allowed\");\r\n        require(getAuctionEndTime(_auctionId) < block.timestamp, \"claim: Auction has not yet ended\");\r\n        require(auctionItemClaimed[_auctionId] == false, \"claim: Item has already been claimed\");\r\n\r\n        //Prevents re-entrancy\r\n        auctionItemClaimed[_auctionId] = true;\r\n\r\n        uint256 _proceeds;\r\n        uint256 remainingFunds;\r\n        if(auctions[_auctionId].secondHighestBid == 0) {\r\n            _proceeds = auctions[_auctionId].highestBid - auctions[_auctionId].auctionDebt;\r\n        } else {\r\n            _proceeds = auctions[_auctionId].secondHighestBid - auctions[_auctionId].auctionDebt;\r\n            remainingFunds = auctions[_auctionId].highestBid - auctions[_auctionId].secondHighestBid;\r\n        }\r\n\r\n        //Added to prevent revert\r\n        IERC20(erc20Currency).approve(address(this), 2**256 - 1);\r\n\r\n        IERC20(erc20Currency).transferFrom(address(this), previousOwnerForReAuction[_tid], (_proceeds * 7000) / 10000);\r\n\r\n        IERC20(erc20Currency).transferFrom(address(this), daoTreasury, (_proceeds * 3000) / 10000);\r\n\r\n        if(remainingFunds > 0 ) {\r\n            IERC20(erc20Currency).transferFrom(address(this), auctions[_auctionId].highestBidder, remainingFunds);\r\n        }\r\n\r\n        if (tokenMapping[_auctionId].tokenKind == bytes4(keccak256(\"ERC721\"))) {\r\n            //0x73ad2146\r\n            IERC721(_contractAddress).safeTransferFrom(address(this), auctions[_auctionId].highestBidder, _tid);\r\n        } else if (tokenMapping[_auctionId].tokenKind == bytes4(keccak256(\"ERC1155\"))) {\r\n            //0x973bb640\r\n            IERC1155(_contractAddress).safeTransferFrom(address(this), auctions[_auctionId].highestBidder, _tid, 1, \"\");\r\n            erc1155TokensUnderAuction[_contractAddress][_tid] = erc1155TokensUnderAuction[_contractAddress][_tid] - 1;\r\n        }\r\n\r\n        emit Auction_ItemClaimed(_auctionId);\r\n    }\r\n\r\n    function takeERC721Back(address _from, uint256 _id) external onlyOwner {\r\n        require(block.timestamp >= IEconNFTERC721(econNFT).getCurrentExpirationTimestamp(), \"EconAuctionHouse: Period has not passed yet\");\r\n        previousOwnerForReAuction[_id] = _from;\r\n        IERC721(econNFT).safeTransferFrom(_from, address(this), _id);\r\n    }\r\n\r\n    function resetAuctionState(uint256 _auctionId, address _nftContract) public onlyOwner {\r\n        registerAnAuctionContract(_nftContract, 0, 0, 0, 0, 0, 0, 0);\r\n        auctions[_auctionId].owner = address(0);\r\n        auctions[_auctionId].highestBidder = address(0);\r\n        auctions[_auctionId].highestBid = 0;\r\n        auctions[_auctionId].auctionDebt = 0;\r\n        auctions[_auctionId].dueIncentives = 0;\r\n        auctions[_auctionId].contractAddress = address(0);\r\n        auctions[_auctionId].startTime = 0;\r\n        auctions[_auctionId].endTime = 0;\r\n        auctions[_auctionId].hammerTimeDuration = 0;\r\n        auctions[_auctionId].bidDecimals = 0;\r\n        auctions[_auctionId].stepMin = 0;\r\n        auctions[_auctionId].incMin = 0;\r\n        auctions[_auctionId].incMax = 0;\r\n        auctions[_auctionId].bidMultiplier = 0;\r\n        auctions[_auctionId].biddingAllowed = false;\r\n        auctionItemClaimed[_auctionId] = false;\r\n        collections[_nftContract].biddingAllowed = false;\r\n    }\r\n\r\n    /// @notice Allow/disallow bidding and claiming for a whole token contract address.\r\n    /// @param _contract The token contract the auctionned token belong to\r\n    /// @param _value True if bidding/claiming should be allowed.\r\n    function setBiddingAllowed(address _contract, bool _value) external onlyOwner {\r\n        collections[_contract].biddingAllowed = _value;\r\n        emit Contract_BiddingAllowed(_contract, _value);\r\n    }\r\n\r\n    function setErc20Currency(address _currency) external onlyOwner {\r\n        erc20Currency = _currency;\r\n    }\r\n\r\n    function setDaoTreasury(address _dao) external onlyOwner {\r\n        daoTreasury = _dao;\r\n    }\r\n\r\n    function getErc20Currency() external view returns (address) {\r\n        return erc20Currency;\r\n    }\r\n\r\n    function getDaoTreasury() external view returns(address) {\r\n        return daoTreasury;\r\n    }\r\n\r\n    function getAuctionInfo(uint256 _auctionId) external view returns (Auction memory auctionInfo_) {\r\n        auctionInfo_ = auctions[_auctionId];\r\n        auctionInfo_.contractAddress = tokenMapping[_auctionId].contractAddress;\r\n        auctionInfo_.biddingAllowed = collections[tokenMapping[_auctionId].contractAddress].biddingAllowed;\r\n    }\r\n\r\n    function getAuctionHighestBidder(uint256 _auctionId) external view returns (address) {\r\n        return auctions[_auctionId].highestBidder;\r\n    }\r\n\r\n    function getAuctionHighestBid(uint256 _auctionId) external view returns (uint256) {\r\n        return auctions[_auctionId].highestBid;\r\n    }\r\n\r\n    function getAuctionDebt(uint256 _auctionId) external view returns (uint256) {\r\n        return auctions[_auctionId].auctionDebt;\r\n    }\r\n\r\n    function getAuctionDueIncentives(uint256 _auctionId) external view returns (uint256) {\r\n        return auctions[_auctionId].dueIncentives;\r\n    }\r\n\r\n    function getAuctionID(address _contract, uint256 _tokenID) external view returns (uint256) {\r\n        return auctionMapping[_contract][_tokenID][0];\r\n    }\r\n\r\n    function getContractFromId(uint256 _auctionId) public view returns(address) {\r\n        return(tokenMapping[_auctionId].contractAddress);\r\n    }\r\n\r\n    function getBiddingAllowed(uint256 _auctionId) public view returns(bool) {\r\n        return(collections[tokenMapping[_auctionId].contractAddress].biddingAllowed);\r\n    }\r\n\r\n    // function getAuctionID(\r\n    //     address _contract,\r\n    //     uint256 _tokenID,\r\n    //     uint256 _tokenIndex\r\n    // ) external view returns (uint256) {\r\n    //     return s.auctionMapping[_contract][_tokenID][_tokenIndex];\r\n    // }\r\n\r\n    function getTokenKind(uint256 _auctionId) external view returns (bytes4) {\r\n        return tokenMapping[_auctionId].tokenKind;\r\n    }\r\n\r\n    function getTokenId(uint256 _auctionId) external view returns (uint256) {\r\n        return tokenMapping[_auctionId].tokenId;\r\n    }\r\n\r\n    function getContractAddress(uint256 _auctionId) external view returns (address) {\r\n        return tokenMapping[_auctionId].contractAddress;\r\n    }\r\n\r\n    function getAuctionStartTime(uint256 _auctionId) public view returns (uint256) {\r\n        if (auctions[_auctionId].startTime != 0) {\r\n            return auctions[_auctionId].startTime;\r\n        } else {\r\n            return collections[tokenMapping[_auctionId].contractAddress].startTime;\r\n        }\r\n    }\r\n\r\n    function getAuctionEndTime(uint256 _auctionId) public view returns (uint256) {\r\n        if (auctions[_auctionId].endTime != 0) {\r\n            return auctions[_auctionId].endTime;\r\n        } else {\r\n            return collections[tokenMapping[_auctionId].contractAddress].endTime;\r\n        }\r\n    }\r\n\r\n    function getAuctionHammerTimeDuration(uint256 _auctionId) public view returns (uint256) {\r\n        if (auctions[_auctionId].hammerTimeDuration != 0) {\r\n            return auctions[_auctionId].hammerTimeDuration;\r\n        } else {\r\n            return collections[tokenMapping[_auctionId].contractAddress].hammerTimeDuration;\r\n        }\r\n    }\r\n\r\n    function getAuctionBidDecimals(uint256 _auctionId) public view returns (uint256) {\r\n        if (auctions[_auctionId].bidDecimals != 0) {\r\n            return auctions[_auctionId].bidDecimals;\r\n        } else {\r\n            return collections[tokenMapping[_auctionId].contractAddress].bidDecimals;\r\n        }\r\n    }\r\n\r\n    function getAuctionStepMin(uint256 _auctionId) public view returns (uint256) {\r\n        if (auctions[_auctionId].stepMin != 0) {\r\n            return auctions[_auctionId].stepMin;\r\n        } else {\r\n            return collections[tokenMapping[_auctionId].contractAddress].stepMin;\r\n        }\r\n    }\r\n\r\n    function getAuctionIncMin(uint256 _auctionId) public view returns (uint256) {\r\n        if (auctions[_auctionId].incMin != 0) {\r\n            return auctions[_auctionId].incMin;\r\n        } else {\r\n            return collections[tokenMapping[_auctionId].contractAddress].incMin;\r\n        }\r\n    }\r\n\r\n    function getAuctionIncMax(uint256 _auctionId) public view returns (uint256) {\r\n        if (auctions[_auctionId].incMax != 0) {\r\n            return auctions[_auctionId].incMax;\r\n        } else {\r\n            return collections[tokenMapping[_auctionId].contractAddress].incMax;\r\n        }\r\n    }\r\n\r\n    function getAuctionBidMultiplier(uint256 _auctionId) public view returns (uint256) {\r\n        if (auctions[_auctionId].bidMultiplier != 0) {\r\n            return auctions[_auctionId].bidMultiplier;\r\n        } else {\r\n            return collections[tokenMapping[_auctionId].contractAddress].bidMultiplier;\r\n        }\r\n    }\r\n\r\n    function onERC721Received(\r\n        address, /* _operator */\r\n        address, /*  _from */\r\n        uint256, /*  _tokenId */\r\n        bytes calldata /* _data */\r\n    ) external pure returns (bytes4) {\r\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address, /* _operator */\r\n        address, /* _from */\r\n        uint256, /* _id */\r\n        uint256, /* _value */\r\n        bytes calldata /* _data */\r\n    ) external pure returns (bytes4) {\r\n        return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address, /* _operator */\r\n        address, /* _from */\r\n        uint256[] calldata, /* _ids */\r\n        uint256[] calldata, /* _values */\r\n        bytes calldata /* _data */\r\n    ) external pure returns (bytes4) {\r\n        return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"));\r\n    }\r\n\r\n    /// @notice Calculating and setting how much payout a bidder will receive if outbid\r\n    /// @dev Only callable internally\r\n    function calculateIncentives(uint256 _auctionId, uint256 _newBidValue) internal view returns (uint256) {\r\n        uint256 bidDecimals = getAuctionBidDecimals(_auctionId);\r\n        uint256 bidIncMax = getAuctionIncMax(_auctionId);\r\n\r\n        // Init the baseline bid we need to perform against\r\n        uint256 baseBid = (auctions[_auctionId].highestBid * (bidDecimals + getAuctionStepMin(_auctionId))) / bidDecimals;\r\n\r\n        // If no bids are present, set a basebid value of 1 to prevent divide by 0 errors\r\n        if (baseBid == 0) {\r\n            baseBid = 1;\r\n        }\r\n\r\n        // Ratio of newBid compared to expected minBid\r\n        uint256 decimaledRatio = ((bidDecimals * getAuctionBidMultiplier(_auctionId) * (_newBidValue - baseBid)) / baseBid) +\r\n            getAuctionIncMin(_auctionId) *\r\n            bidDecimals;\r\n\r\n        if (decimaledRatio > (bidDecimals * bidIncMax)) {\r\n            decimaledRatio = bidDecimals * bidIncMax;\r\n        }\r\n\r\n        return (_newBidValue * decimaledRatio) / (bidDecimals * bidDecimals);\r\n    }\r\n}"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\r\npragma solidity ^0.8.0;\r\n\r\n/// @title ERC20 interface\r\n/// @dev https://github.com/ethereum/EIPs/issues/20\r\ninterface IERC20 {\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n\tfunction totalSupply() external view returns (uint256);\r\n\tfunction balanceOf(address who) external view returns (uint256);\r\n\tfunction allowance(address owner, address spender) external view returns (uint256);\r\n\tfunction transfer(address to, uint256 value) external returns (bool);\r\n\tfunction approve(address spender, uint256 value) external returns (bool);\r\n\tfunction transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}"
    },
    "contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\r\npragma solidity ^0.8.0;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface IERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n"
    },
    "contracts/interfaces/IERC721TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\r\npragma solidity ^0.8.0;\r\n\r\n/// @title IERC721TokenReceiver\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721. Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface IERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\r\n}"
    },
    "contracts/interfaces/IERC1155TokenReceiver.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n    Note: The ERC-165 identifier for this interface is 0x4e2312e0.\r\n*/\r\ninterface IERC1155TokenReceiver {\r\n    /**\r\n        @notice Handle the receipt of a single ERC1155 token type.\r\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.        \r\n        This function MUST return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` (i.e. 0xf23a6e61) if it accepts the transfer.\r\n        This function MUST revert if it rejects the transfer.\r\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\r\n        @param _operator  The address which initiated the transfer (i.e. msg.sender)\r\n        @param _from      The address which previously owned the token\r\n        @param _id        The ID of the token being transferred\r\n        @param _value     The amount of tokens being transferred\r\n        @param _data      Additional data with no specified format\r\n        @return           `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n    */\r\n    function onERC1155Received(address _operator, address _from, uint256 _id, uint256 _value, bytes calldata _data) external returns(bytes4);\r\n\r\n    /**\r\n        @notice Handle the receipt of multiple ERC1155 token types.\r\n        @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.        \r\n        This function MUST return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` (i.e. 0xbc197c81) if it accepts the transfer(s).\r\n        This function MUST revert if it rejects the transfer(s).\r\n        Return of any other value than the prescribed keccak256 generated value MUST result in the transaction being reverted by the caller.\r\n        @param _operator  The address which initiated the batch transfer (i.e. msg.sender)\r\n        @param _from      The address which previously owned the token\r\n        @param _ids       An array containing ids of each token being transferred (order and length must match _values array)\r\n        @param _values    An array containing amounts of each token being transferred (order and length must match _ids array)\r\n        @param _data      Additional data with no specified format\r\n        @return           `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n    */\r\n    function onERC1155BatchReceived(address _operator, address _from, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external returns(bytes4);       \r\n}"
    },
    "contracts/GBMAuctionFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n//  Copyright 2021. Patent pending. All rights reserved. Perpetual Altruism Ltd.\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./interfaces/IGBM.sol\";\r\nimport \"./interfaces/IGBMInitiator.sol\";\r\nimport \"./interfaces/IERC20.sol\";\r\nimport \"./interfaces/IERC721.sol\";\r\nimport \"./interfaces/IERC721TokenReceiver.sol\";\r\nimport \"./interfaces/IERC1155.sol\";\r\nimport \"./interfaces/IERC1155TokenReceiver.sol\";\r\nimport \"./interfaces/Ownable.sol\";\r\nimport \"./libraries/AppStorage.sol\";\r\nimport \"./libraries/LibDiamond.sol\";\r\nimport \"./libraries/LibSignature.sol\";\r\n\r\n/// @title GBM auction contract\r\n/// @dev See GBM.auction on how to use this contract\r\n/// @author Guillaume Gonnaud\r\ncontract GBMAuctionFacet is IGBM, IERC1155TokenReceiver, IERC721TokenReceiver, Modifiers {\r\n    function erc20Currency() external view override returns (address) {\r\n        return s.erc20Currency;\r\n    }\r\n\r\n    /// @notice Place a GBM bid for a GBM auction\r\n    /// @param _auctionId The auction you want to bid on\r\n    /// @param _bidAmount The amount of the ERC20 token the bid is made of. They should be withdrawable by this contract.\r\n    /// @param _highestBid The current higest bid. Throw if incorrect.\r\n    /// @param _signature Signature\r\n    function commitBid(\r\n        uint256 _auctionId,\r\n        uint256 _bidAmount,\r\n        uint256 _highestBid,\r\n        bytes memory _signature\r\n    ) external {\r\n        bytes32 messageHash = keccak256(abi.encodePacked(msg.sender, _auctionId, _bidAmount, _highestBid));\r\n        require(LibSignature.isValid(messageHash, _signature, s.backendPubKey), \"bid: Invalid signature\");\r\n\r\n        bid(_auctionId, _bidAmount, _highestBid);\r\n    }\r\n\r\n    /// @notice Place a GBM bid for a GBM auction\r\n    /// @param _auctionId The auction you want to bid on\r\n    /// @param _bidAmount The amount of the ERC20 token the bid is made of. They should be withdrawable by this contract.\r\n    /// @param _highestBid The current higest bid. Throw if incorrect.\r\n    function bid(\r\n        uint256 _auctionId,\r\n        uint256 _bidAmount,\r\n        uint256 _highestBid\r\n    ) internal {\r\n        require(s.collections[s.tokenMapping[_auctionId].contractAddress].biddingAllowed, \"bid: bidding is currently not allowed\");\r\n\r\n        require(_bidAmount > 1, \"bid: _bidAmount cannot be 0\");\r\n\r\n        require(_highestBid == s.auctions[_auctionId].highestBid, \"bid: current highest bid does not match the submitted transaction _highestBid\");\r\n\r\n        //An auction start time of 0 also indicate the auction has not been created at all\r\n\r\n        require(getAuctionStartTime(_auctionId) <= block.timestamp && getAuctionStartTime(_auctionId) != 0, \"bid: Auction has not started yet\");\r\n        require(getAuctionEndTime(_auctionId) >= block.timestamp, \"bid: Auction has already ended\");\r\n\r\n        require(_bidAmount > _highestBid, \"bid: _bidAmount must be higher than _highestBid\");\r\n\r\n        require(\r\n            // (_highestBid * (getAuctionBidDecimals(_auctionId)) + (getAuctionStepMin(_auctionId) / getAuctionBidDecimals(_auctionId))) >= _highestBid,\r\n            // \"bid: _bidAmount must meet the minimum bid\"\r\n\r\n            (_highestBid * (getAuctionBidDecimals(_auctionId) + getAuctionStepMin(_auctionId))) <= (_bidAmount * getAuctionBidDecimals(_auctionId)),\r\n            \"bid: _bidAmount must meet the minimum bid\"\r\n        );\r\n\r\n        //Transfer the money of the bidder to the GBM smart contract\r\n        IERC20(s.erc20Currency).transferFrom(msg.sender, address(this), _bidAmount);\r\n\r\n        //Extend the duration time of the auction if we are close to the end\r\n        if (getAuctionEndTime(_auctionId) < block.timestamp + getAuctionHammerTimeDuration(_auctionId)) {\r\n            s.auctions[_auctionId].endTime = block.timestamp + getAuctionHammerTimeDuration(_auctionId);\r\n            emit Auction_EndTimeUpdated(_auctionId, s.auctions[_auctionId].endTime);\r\n        }\r\n\r\n        // Saving incentives for later sending\r\n        uint256 duePay = s.auctions[_auctionId].dueIncentives;\r\n        address previousHighestBidder = s.auctions[_auctionId].highestBidder;\r\n        uint256 previousHighestBid = s.auctions[_auctionId].highestBid;\r\n\r\n        // Emitting the event sequence\r\n        if (previousHighestBidder != address(0)) {\r\n            emit Auction_BidRemoved(_auctionId, previousHighestBidder, previousHighestBid);\r\n        }\r\n\r\n        if (duePay != 0) {\r\n            s.auctions[_auctionId].auctionDebt = s.auctions[_auctionId].auctionDebt + duePay;\r\n            emit Auction_IncentivePaid(_auctionId, previousHighestBidder, duePay);\r\n        }\r\n\r\n        emit Auction_BidPlaced(_auctionId, msg.sender, _bidAmount);\r\n\r\n        // Calculating incentives for the new bidder\r\n        s.auctions[_auctionId].dueIncentives = calculateIncentives(_auctionId, _bidAmount);\r\n\r\n        //Setting the new bid/bidder as the highest bid/bidder\r\n        s.auctions[_auctionId].highestBidder = msg.sender;\r\n        s.auctions[_auctionId].highestBid = _bidAmount;\r\n\r\n        if ((previousHighestBid + duePay) != 0) {\r\n            //Refunding the previous bid as well as sending the incentives\r\n\r\n            //Added to prevent revert\r\n            IERC20(s.erc20Currency).approve(address(this), (previousHighestBid + duePay));\r\n\r\n            IERC20(s.erc20Currency).transferFrom(address(this), previousHighestBidder, (previousHighestBid + duePay));\r\n        }\r\n    }\r\n\r\n    function batchClaim(uint256[] memory _auctionIds) external override {\r\n        for (uint256 index = 0; index < _auctionIds.length; index++) {\r\n            claim(_auctionIds[index]);\r\n        }\r\n    }\r\n\r\n    function updatePlayerRewardsAddress(address _newAddress) external onlyOwner {\r\n        s.playerRewards = _newAddress;\r\n    }\r\n\r\n    /// @notice Attribute a token to the winner of the auction and distribute the proceeds to the owner of this contract.\r\n    /// throw if bidding is disabled or if the auction is not finished.\r\n    /// @param _auctionId The auctionId of the auction to complete\r\n    function claim(uint256 _auctionId) public override {\r\n        address _ca = s.tokenMapping[_auctionId].contractAddress;\r\n        uint256 _tid = s.tokenMapping[_auctionId].tokenId;\r\n\r\n        require(s.collections[_ca].biddingAllowed, \"claim: Claiming is currently not allowed\");\r\n        require(getAuctionEndTime(_auctionId) < block.timestamp, \"claim: Auction has not yet ended\");\r\n        require(s.auctionItemClaimed[_auctionId] == false, \"claim: Item has already been claimed\");\r\n\r\n        //Prevents re-entrancy\r\n        s.auctionItemClaimed[_auctionId] = true;\r\n\r\n        //Todo: Add in the various Aavegotchi addresses\r\n        uint256 _proceeds = s.auctions[_auctionId].highestBid - s.auctions[_auctionId].auctionDebt;\r\n\r\n        //Added to prevent revert\r\n        IERC20(s.erc20Currency).approve(address(this), _proceeds);\r\n\r\n        //Transfer the proceeds to the various recipients\r\n\r\n        //5% to burn address\r\n        uint256 burnShare = (_proceeds * 5) / 100;\r\n\r\n        //40% to Pixelcraft wallet\r\n        uint256 companyShare = (_proceeds * 40) / 100;\r\n\r\n        //40% to player rewards\r\n        uint256 playerRewardsShare = (_proceeds * 2) / 5;\r\n\r\n        //15% to DAO\r\n        uint256 daoShare = (_proceeds - burnShare - companyShare - playerRewardsShare);\r\n\r\n        IERC20(s.erc20Currency).transferFrom(address(this), address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF), burnShare);\r\n        IERC20(s.erc20Currency).transferFrom(address(this), s.pixelcraft, companyShare);\r\n        IERC20(s.erc20Currency).transferFrom(address(this), s.playerRewards, playerRewardsShare);\r\n        IERC20(s.erc20Currency).transferFrom(address(this), s.daoTreasury, daoShare);\r\n\r\n        //todo: test\r\n        if (s.auctions[_auctionId].highestBid == 0) {\r\n            s.auctions[_auctionId].highestBidder = LibDiamond.contractOwner();\r\n        }\r\n\r\n        if (s.tokenMapping[_auctionId].tokenKind == bytes4(keccak256(\"ERC721\"))) {\r\n            //0x73ad2146\r\n            IERC721(_ca).safeTransferFrom(address(this), s.auctions[_auctionId].highestBidder, _tid);\r\n        } else if (s.tokenMapping[_auctionId].tokenKind == bytes4(keccak256(\"ERC1155\"))) {\r\n            //0x973bb640\r\n            IERC1155(_ca).safeTransferFrom(address(this), s.auctions[_auctionId].highestBidder, _tid, 1, \"\");\r\n            s.erc1155TokensUnderAuction[_ca][_tid] = s.erc1155TokensUnderAuction[_ca][_tid] - 1;\r\n        }\r\n\r\n        emit Auction_ItemClaimed(_auctionId);\r\n    }\r\n\r\n    /// @notice Register an auction contract default parameters for a GBM auction. To use to save gas\r\n    /// @param _contract The token contract the auctionned token belong to\r\n    function registerAnAuctionContract(address _contract) public onlyOwner {\r\n        s.collections[_contract].startTime = s.initiatorInfo.startTime;\r\n        s.collections[_contract].endTime = s.initiatorInfo.endTime;\r\n        s.collections[_contract].hammerTimeDuration = s.initiatorInfo.hammerTimeDuration;\r\n        s.collections[_contract].bidDecimals = s.initiatorInfo.bidDecimals;\r\n        s.collections[_contract].stepMin = s.initiatorInfo.stepMin;\r\n        s.collections[_contract].incMin = s.initiatorInfo.incMin;\r\n        s.collections[_contract].incMax = s.initiatorInfo.incMax;\r\n        s.collections[_contract].bidMultiplier = s.initiatorInfo.bidMultiplier;\r\n    }\r\n\r\n    /// @notice Allow/disallow bidding and claiming for a whole token contract address.\r\n    /// @param _contract The token contract the auctionned token belong to\r\n    /// @param _value True if bidding/claiming should be allowed.\r\n    function setBiddingAllowed(address _contract, bool _value) external onlyOwner {\r\n        s.collections[_contract].biddingAllowed = _value;\r\n        emit Contract_BiddingAllowed(_contract, _value);\r\n    }\r\n\r\n    /// @notice Register an auction token and emit the relevant AuctionInitialized & AuctionStartTimeUpdated events\r\n    /// Throw if the token owner is not the GBM smart contract/supply of auctionned 1155 token is insufficient\r\n    /// @param _tokenContract The token contract the auctionned token belong to\r\n    /// @param _tokenId The token ID of the token being auctionned\r\n    /// @param _tokenKind either bytes4(keccak256(\"ERC721\")) or bytes4(keccak256(\"ERC1155\"))\r\n    /// @param _useInitiator Set to `false` if you want to use the default value registered for the token contract (if wanting to reset to default,\r\n    /// use `true`)\r\n    function registerAnAuctionToken(\r\n        address _tokenContract,\r\n        uint256 _tokenId,\r\n        bytes4 _tokenKind,\r\n        bool _useInitiator\r\n    ) public onlyOwner {\r\n        modifyAnAuctionToken(_tokenContract, _tokenId, _tokenKind, _useInitiator, 0, false);\r\n    }\r\n\r\n    /// @notice Register an auction token and emit the relevant AuctionInitialized & AuctionStartTimeUpdated events\r\n    /// Throw if the token owner is not the GBM smart contract/supply of auctionned 1155 token is insufficient\r\n    /// @param _tokenContract The token contract the auctionned token belong to\r\n    /// @param _tokenId The token ID of the token being auctionned\r\n    /// @param _tokenKind either bytes4(keccak256(\"ERC721\")) or bytes4(keccak256(\"ERC1155\"))\r\n    /// @param _useInitiator Set to `false` if you want to use the default value registered for the token contract (if wanting to reset to default,\r\n    /// use `true`)\r\n    /// @param _1155Index Set to 0 if dealing with an ERC-721 or registering new 1155 test. otherwise, set to relevant index you want to reinitialize\r\n    /// @param _rewrite Set to true if you want to rewrite the data of an existing auction, false otherwise\r\n    function modifyAnAuctionToken(\r\n        address _tokenContract,\r\n        uint256 _tokenId,\r\n        bytes4 _tokenKind,\r\n        bool _useInitiator,\r\n        uint256 _1155Index,\r\n        bool _rewrite\r\n    ) internal {\r\n        if (!_rewrite) {\r\n            _1155Index = s.erc1155TokensIndex[_tokenContract][_tokenId]; //_1155Index was 0 if creating new auctions\r\n            require(s.auctionMapping[_tokenContract][_tokenId][_1155Index] == 0, \"The auction aleady exist for the specified token\");\r\n        } else {\r\n            require(s.auctionMapping[_tokenContract][_tokenId][_1155Index] != 0, \"The auction doesn't exist yet for the specified token\");\r\n        }\r\n\r\n        //Checking the kind of token being registered\r\n        require(\r\n            _tokenKind == bytes4(keccak256(\"ERC721\")) || _tokenKind == bytes4(keccak256(\"ERC1155\")),\r\n            \"registerAnAuctionToken: Only ERC1155 and ERC721 tokens are supported\"\r\n        );\r\n\r\n        //Building the auction object\r\n        TokenRepresentation memory newAuction;\r\n        newAuction.contractAddress = _tokenContract;\r\n        newAuction.tokenId = _tokenId;\r\n        newAuction.tokenKind = _tokenKind;\r\n\r\n        uint256 _auctionId;\r\n\r\n        if (_tokenKind == bytes4(keccak256(\"ERC721\"))) {\r\n            require(\r\n                msg.sender == Ownable(_tokenContract).owner() || address(this) == IERC721(_tokenContract).ownerOf(_tokenId),\r\n                \"registerAnAuctionToken: the specified ERC-721 token cannot be auctioned\"\r\n            );\r\n\r\n            _auctionId = uint256(keccak256(abi.encodePacked(_tokenContract, _tokenId, _tokenKind)));\r\n            s.auctionMapping[_tokenContract][_tokenId][0] = _auctionId;\r\n        } else {\r\n            require(\r\n                msg.sender == Ownable(_tokenContract).owner() ||\r\n                    s.erc1155TokensUnderAuction[_tokenContract][_tokenId] < IERC1155(_tokenContract).balanceOf(address(this), _tokenId),\r\n                \"registerAnAuctionToken:  the specified ERC-1155 token cannot be auctionned\"\r\n            );\r\n\r\n            require(\r\n                _1155Index <= s.erc1155TokensIndex[_tokenContract][_tokenId],\r\n                \"The specified _1155Index have not been reached yet for this token\"\r\n            );\r\n\r\n            _auctionId = uint256(keccak256(abi.encodePacked(_tokenContract, _tokenId, _tokenKind, _1155Index)));\r\n\r\n            if (!_rewrite) {\r\n                s.erc1155TokensIndex[_tokenContract][_tokenId] = s.erc1155TokensIndex[_tokenContract][_tokenId] + 1;\r\n                s.erc1155TokensUnderAuction[_tokenContract][_tokenId] = s.erc1155TokensUnderAuction[_tokenContract][_tokenId] + 1;\r\n            }\r\n\r\n            s.auctionMapping[_tokenContract][_tokenId][_1155Index] = _auctionId;\r\n        }\r\n\r\n        s.tokenMapping[_auctionId] = newAuction;\r\n\r\n        if (_useInitiator) {\r\n            s.auctions[_auctionId].owner = LibDiamond.contractOwner();\r\n            s.auctions[_auctionId].startTime = s.initiatorInfo.startTime;\r\n            s.auctions[_auctionId].endTime = s.initiatorInfo.endTime;\r\n            s.auctions[_auctionId].hammerTimeDuration = s.initiatorInfo.hammerTimeDuration;\r\n            s.auctions[_auctionId].bidDecimals = s.initiatorInfo.bidDecimals;\r\n            s.auctions[_auctionId].stepMin = s.initiatorInfo.stepMin;\r\n            s.auctions[_auctionId].incMin = s.initiatorInfo.incMin;\r\n            s.auctions[_auctionId].incMax = s.initiatorInfo.incMax;\r\n            s.auctions[_auctionId].bidMultiplier = s.initiatorInfo.bidMultiplier;\r\n        }\r\n\r\n        //Event emitted when an auction is being setup\r\n        emit Auction_Initialized(_auctionId, _tokenId, _1155Index, _tokenContract, _tokenKind);\r\n\r\n        //Event emitted when the start time of an auction changes (due to admin interaction )\r\n        emit Auction_StartTimeUpdated(_auctionId, getAuctionStartTime(_auctionId));\r\n    }\r\n\r\n    function getAuctionInfo(uint256 _auctionId) external view returns (Auction memory auctionInfo_) {\r\n        auctionInfo_ = s.auctions[_auctionId];\r\n        auctionInfo_.contractAddress = s.tokenMapping[_auctionId].contractAddress;\r\n        auctionInfo_.biddingAllowed = s.collections[s.tokenMapping[_auctionId].contractAddress].biddingAllowed;\r\n    }\r\n\r\n    function getAuctionHighestBidder(uint256 _auctionId) external view override returns (address) {\r\n        return s.auctions[_auctionId].highestBidder;\r\n    }\r\n\r\n    function getAuctionHighestBid(uint256 _auctionId) external view override returns (uint256) {\r\n        return s.auctions[_auctionId].highestBid;\r\n    }\r\n\r\n    function getAuctionDebt(uint256 _auctionId) external view override returns (uint256) {\r\n        return s.auctions[_auctionId].auctionDebt;\r\n    }\r\n\r\n    function getAuctionDueIncentives(uint256 _auctionId) external view override returns (uint256) {\r\n        return s.auctions[_auctionId].dueIncentives;\r\n    }\r\n\r\n    function getAuctionID(address _contract, uint256 _tokenID) external view override returns (uint256) {\r\n        return s.auctionMapping[_contract][_tokenID][0];\r\n    }\r\n\r\n    function getAuctionID(\r\n        address _contract,\r\n        uint256 _tokenID,\r\n        uint256 _tokenIndex\r\n    ) external view override returns (uint256) {\r\n        return s.auctionMapping[_contract][_tokenID][_tokenIndex];\r\n    }\r\n\r\n    function getTokenKind(uint256 _auctionId) external view override returns (bytes4) {\r\n        return s.tokenMapping[_auctionId].tokenKind;\r\n    }\r\n\r\n    function getTokenId(uint256 _auctionId) external view override returns (uint256) {\r\n        return s.tokenMapping[_auctionId].tokenId;\r\n    }\r\n\r\n    function getContractAddress(uint256 _auctionId) external view override returns (address) {\r\n        return s.tokenMapping[_auctionId].contractAddress;\r\n    }\r\n\r\n    function getAuctionStartTime(uint256 _auctionId) public view override returns (uint256) {\r\n        if (s.auctions[_auctionId].startTime != 0) {\r\n            return s.auctions[_auctionId].startTime;\r\n        } else {\r\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].startTime;\r\n        }\r\n    }\r\n\r\n    function getAuctionEndTime(uint256 _auctionId) public view override returns (uint256) {\r\n        if (s.auctions[_auctionId].endTime != 0) {\r\n            return s.auctions[_auctionId].endTime;\r\n        } else {\r\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].endTime;\r\n        }\r\n    }\r\n\r\n    function getAuctionHammerTimeDuration(uint256 _auctionId) public view override returns (uint256) {\r\n        if (s.auctions[_auctionId].hammerTimeDuration != 0) {\r\n            return s.auctions[_auctionId].hammerTimeDuration;\r\n        } else {\r\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].hammerTimeDuration;\r\n        }\r\n    }\r\n\r\n    function getAuctionBidDecimals(uint256 _auctionId) public view override returns (uint256) {\r\n        if (s.auctions[_auctionId].bidDecimals != 0) {\r\n            return s.auctions[_auctionId].bidDecimals;\r\n        } else {\r\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].bidDecimals;\r\n        }\r\n    }\r\n\r\n    function getAuctionStepMin(uint256 _auctionId) public view override returns (uint256) {\r\n        if (s.auctions[_auctionId].stepMin != 0) {\r\n            return s.auctions[_auctionId].stepMin;\r\n        } else {\r\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].stepMin;\r\n        }\r\n    }\r\n\r\n    function getAuctionIncMin(uint256 _auctionId) public view override returns (uint256) {\r\n        if (s.auctions[_auctionId].incMin != 0) {\r\n            return s.auctions[_auctionId].incMin;\r\n        } else {\r\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].incMin;\r\n        }\r\n    }\r\n\r\n    function getAuctionIncMax(uint256 _auctionId) public view override returns (uint256) {\r\n        if (s.auctions[_auctionId].incMax != 0) {\r\n            return s.auctions[_auctionId].incMax;\r\n        } else {\r\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].incMax;\r\n        }\r\n    }\r\n\r\n    function getAuctionBidMultiplier(uint256 _auctionId) public view override returns (uint256) {\r\n        if (s.auctions[_auctionId].bidMultiplier != 0) {\r\n            return s.auctions[_auctionId].bidMultiplier;\r\n        } else {\r\n            return s.collections[s.tokenMapping[_auctionId].contractAddress].bidMultiplier;\r\n        }\r\n    }\r\n\r\n    function onERC721Received(\r\n        address, /* _operator */\r\n        address, /*  _from */\r\n        uint256, /*  _tokenId */\r\n        bytes calldata /* _data */\r\n    ) external pure override returns (bytes4) {\r\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n    }\r\n\r\n    function onERC1155Received(\r\n        address, /* _operator */\r\n        address, /* _from */\r\n        uint256, /* _id */\r\n        uint256, /* _value */\r\n        bytes calldata /* _data */\r\n    ) external pure override returns (bytes4) {\r\n        return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"));\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address, /* _operator */\r\n        address, /* _from */\r\n        uint256[] calldata, /* _ids */\r\n        uint256[] calldata, /* _values */\r\n        bytes calldata /* _data */\r\n    ) external pure override returns (bytes4) {\r\n        return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"));\r\n    }\r\n\r\n    /// @notice Calculating and setting how much payout a bidder will receive if outbid\r\n    /// @dev Only callable internally\r\n    function calculateIncentives(uint256 _auctionId, uint256 _newBidValue) internal view returns (uint256) {\r\n        uint256 bidDecimals = getAuctionBidDecimals(_auctionId);\r\n        uint256 bidIncMax = getAuctionIncMax(_auctionId);\r\n\r\n        //Init the baseline bid we need to perform against\r\n        uint256 baseBid = (s.auctions[_auctionId].highestBid * (bidDecimals + getAuctionStepMin(_auctionId))) / bidDecimals;\r\n\r\n        //If no bids are present, set a basebid value of 1 to prevent divide by 0 errors\r\n        if (baseBid == 0) {\r\n            baseBid = 1;\r\n        }\r\n\r\n        // Ratio of newBid compared to expected minBid\r\n        uint256 decimaledRatio = ((bidDecimals * getAuctionBidMultiplier(_auctionId) * (_newBidValue - baseBid)) / baseBid) +\r\n            getAuctionIncMin(_auctionId) *\r\n            bidDecimals;\r\n\r\n        if (decimaledRatio > (bidDecimals * bidIncMax)) {\r\n            decimaledRatio = bidDecimals * bidIncMax;\r\n        }\r\n\r\n        return (_newBidValue * decimaledRatio) / (bidDecimals * bidDecimals);\r\n    }\r\n\r\n    function registerMassERC721Each(\r\n        address _GBM,\r\n        bool _useInitiator,\r\n        address _ERC721Contract,\r\n        uint256[] memory _tokenIds\r\n    ) external onlyOwner {\r\n        require(_tokenIds.length > 0, \"No auctions to create\");\r\n        for (uint256 index = 0; index < _tokenIds.length; index++) {\r\n            uint256 tokenId = _tokenIds[index];\r\n            IERC721(_ERC721Contract).safeTransferFrom(msg.sender, _GBM, tokenId, \"\");\r\n            registerAnAuctionToken(_ERC721Contract, tokenId, bytes4(keccak256(\"ERC721\")), _useInitiator);\r\n        }\r\n\r\n        // _tokenIDStart++;\r\n    }\r\n\r\n    function registerMassERC1155Each(\r\n        address _GBM,\r\n        bool _useInitiator,\r\n        address _ERC1155Contract,\r\n        uint256 _tokenID,\r\n        uint256 _indexStart,\r\n        uint256 _indexEnd\r\n    ) external onlyOwner {\r\n        registerAnAuctionContract(_ERC1155Contract);\r\n        IERC1155(_ERC1155Contract).safeTransferFrom(msg.sender, _GBM, _tokenID, _indexEnd - _indexStart, \"\");\r\n        while (_indexStart < _indexEnd) {\r\n            registerAnAuctionToken(_ERC1155Contract, _tokenID, bytes4(keccak256(\"ERC1155\")), _useInitiator);\r\n            _indexStart++;\r\n        }\r\n    }\r\n}"
    },
    "contracts/interfaces/IGBM.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n//  Copyright 2021. Patent pending. All rights reserved. Perpetual Altruism Ltd.\r\npragma solidity ^0.8.0;\r\n\r\n/// @title IGBM GBM auction interface\r\n/// @dev See GBM.auction on how to use this contract\r\n/// @author Guillaume Gonnaud\r\ninterface IGBM {\r\n    //Event emitted when an auction is being setup\r\n    event Auction_Initialized(\r\n        uint256 indexed _auctionID,\r\n        uint256 indexed _tokenID,\r\n        uint256 indexed _tokenIndex,\r\n        address _contractAddress,\r\n        bytes4 _tokenKind\r\n    );\r\n\r\n    //Event emitted when the start time of an auction changes (due to admin interaction )\r\n    event Auction_StartTimeUpdated(uint256 indexed _auctionID, uint256 _startTime);\r\n\r\n    //Event emitted when the end time of an auction changes (be it due to admin interaction or bid at the end)\r\n    event Auction_EndTimeUpdated(uint256 indexed _auctionID, uint256 _endTime);\r\n\r\n    //Event emitted when a Bid is placed\r\n    event Auction_BidPlaced(uint256 indexed _auctionID, address indexed _bidder, uint256 _bidAmount);\r\n\r\n    //Event emitted when a bid is removed (due to a new bid displacing it)\r\n    event Auction_BidRemoved(uint256 indexed _auctionID, address indexed _bidder, uint256 _bidAmount);\r\n\r\n    //Event emitted when incentives are paid (due to a new bid rewarding the _earner bid)\r\n    event Auction_IncentivePaid(uint256 indexed _auctionID, address indexed _earner, uint256 _incentiveAmount);\r\n\r\n    event Contract_BiddingAllowed(address indexed _contract, bool _biddingAllowed);\r\n\r\n    event Auction_ItemClaimed(uint256 indexed _auctionID);\r\n\r\n    //    function bid(\r\n    //        uint256 _auctionID,\r\n    //        uint256 _bidAmount,\r\n    //        uint256 _highestBid\r\n    //    ) external;\r\n\r\n    function batchClaim(uint256[] memory _auctionIds) external;\r\n\r\n    function claim(uint256 _auctionId) external;\r\n\r\n    function erc20Currency() external view returns (address);\r\n\r\n    function getAuctionID(address _contract, uint256 _tokenID) external view returns (uint256);\r\n\r\n    function getAuctionID(\r\n        address _contract,\r\n        uint256 _tokenID,\r\n        uint256 _tokenIndex\r\n    ) external view returns (uint256);\r\n\r\n    function getTokenId(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getContractAddress(uint256 _auctionId) external view returns (address);\r\n\r\n    function getTokenKind(uint256 _auctionId) external view returns (bytes4);\r\n\r\n    function getAuctionHighestBidder(uint256 _auctionId) external view returns (address);\r\n\r\n    function getAuctionHighestBid(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getAuctionDebt(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getAuctionDueIncentives(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getAuctionStartTime(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getAuctionEndTime(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getAuctionHammerTimeDuration(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getAuctionBidDecimals(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getAuctionStepMin(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getAuctionIncMin(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getAuctionIncMax(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getAuctionBidMultiplier(uint256 _auctionId) external view returns (uint256);\r\n}"
    },
    "contracts/interfaces/IGBMInitiator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n//  Copyright 2021. Patent pending. All rights reserved. Perpetual Altruism Ltd.\r\npragma solidity ^0.8.0;\r\n\r\n/// @title IGBMInitiator: GBM Auction initiator interface.\r\n/// @dev Will be called when initializing GBM auctions on the main GBM contract.\r\n/// @author Guillaume Gonnaud\r\ninterface IGBMInitiator {\r\n    // Auction id either = the contract token address cast as uint256 or\r\n    // auctionId = uint256(keccak256(abi.encodePacked(_contract, _tokenId, _tokenKind)));  <= ERC721\r\n    // auctionId = uint256(keccak256(abi.encodePacked(_contract, _tokenId, _tokenKind, _1155Index))); <= ERC1155\r\n\r\n    function getStartTime(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getEndTime(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getHammerTimeDuration(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getBidDecimals(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getStepMin(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getIncMin(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getIncMax(uint256 _auctionId) external view returns (uint256);\r\n\r\n    function getBidMultiplier(uint256 _auctionId) external view returns (uint256);\r\n}"
    },
    "contracts/interfaces/Ownable.sol": {
      "content": "// SPDX-License-Identifier: CC0-1.0\r\npragma solidity ^0.8.0;\r\n\r\ninterface Ownable {\r\n    function owner() external returns(address);\r\n}"
    },
    "contracts/libraries/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\nimport { LibDiamond } from \"./LibDiamond.sol\";\r\n\r\n//Struct used to store the representation of an NFT being auctionned\r\nstruct TokenRepresentation {\r\n    address contractAddress; // The contract address\r\n    uint256 tokenId; // The ID of the token on the contract\r\n    bytes4 tokenKind; // The ERC name of the token implementation bytes4(keccak256(\"ERC721\")) or bytes4(keccak256(\"ERC1155\"))\r\n}\r\n\r\nstruct ContractAddresses {\r\n    address pixelcraft;\r\n    address playerRewards;\r\n    address daoTreasury;\r\n    address erc20Currency;\r\n}\r\n\r\nstruct InitiatorInfo {\r\n    uint256 startTime;\r\n    uint256 endTime;\r\n    uint256 hammerTimeDuration;\r\n    uint256 bidDecimals;\r\n    uint256 stepMin;\r\n    uint256 incMin;\r\n    uint256 incMax;\r\n    uint256 bidMultiplier;\r\n}\r\n\r\nstruct Auction {\r\n    address owner;\r\n    address highestBidder;\r\n    uint256 highestBid;\r\n    uint256 auctionDebt;\r\n    uint256 dueIncentives;\r\n    address contractAddress;\r\n    uint256 startTime;\r\n    uint256 endTime;\r\n    uint256 hammerTimeDuration;\r\n    uint256 bidDecimals;\r\n    uint256 stepMin;\r\n    uint256 incMin;\r\n    uint256 incMax;\r\n    uint256 bidMultiplier;\r\n    bool biddingAllowed;\r\n}\r\n\r\nstruct Collection {\r\n    uint256 startTime;\r\n    uint256 endTime;\r\n    uint256 hammerTimeDuration;\r\n    uint256 bidDecimals;\r\n    uint256 stepMin;\r\n    uint256 incMin; // minimal earned incentives\r\n    uint256 incMax; // maximal earned incentives\r\n    uint256 bidMultiplier; // bid incentive growth multiplier\r\n    bool biddingAllowed; // Allow to start/pause ongoing auctions\r\n}\r\n\r\nstruct AppStorage {\r\n    address pixelcraft;\r\n    address playerRewards;\r\n    address daoTreasury;\r\n    InitiatorInfo initiatorInfo;\r\n    //Contract address storing the ERC20 currency used in auctions\r\n    address erc20Currency;\r\n    mapping(uint256 => TokenRepresentation) tokenMapping; //_auctionId => token_primaryKey\r\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) auctionMapping; // contractAddress => tokenId => TokenIndex => _auctionId\r\n    //var storing individual auction settings. if != null, they take priority over collection settings\r\n    mapping(uint256 => Auction) auctions; //_auctionId => auctions\r\n    mapping(uint256 => bool) auctionItemClaimed;\r\n    //var storing contract wide settings. Those are used if no auctionId specific parameters is initialized\r\n    mapping(address => Collection) collections; //tokencontract => collections\r\n    mapping(address => mapping(uint256 => uint256)) erc1155TokensIndex; //Contract => TokenID => Amount being auctionned\r\n    mapping(address => mapping(uint256 => uint256)) erc1155TokensUnderAuction; //Contract => TokenID => Amount being auctionned\r\n    bytes backendPubKey;\r\n}\r\n\r\ncontract Modifiers {\r\n    AppStorage internal s;\r\n\r\n    modifier onlyOwner() {\r\n        LibDiamond.enforceIsContractOwner();\r\n        _;\r\n    }\r\n}"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\r\n\r\nlibrary LibDiamond {\r\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\r\n\r\n    struct DiamondStorage {\r\n        // maps function selectors to the facets that execute the functions.\r\n        // and maps the selectors to their position in the selectorSlots array.\r\n        // func selector => address facet, selector position\r\n        mapping(bytes4 => bytes32) facets;\r\n        // array of slots of function selectors.\r\n        // each slot holds 8 function selectors.\r\n        mapping(uint256 => bytes32) selectorSlots;\r\n        // The number of function selectors in selectorSlots\r\n        uint16 selectorCount;\r\n        // Used to query if a contract implements an interface.\r\n        // Used to implement ERC-165.\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n        // owner of the contract\r\n        address contractOwner;\r\n    }\r\n\r\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function setContractOwner(address _newOwner) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        address previousOwner = ds.contractOwner;\r\n        ds.contractOwner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function contractOwner() internal view returns (address contractOwner_) {\r\n        contractOwner_ = diamondStorage().contractOwner;\r\n    }\r\n\r\n    function enforceIsContractOwner() internal view {\r\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\r\n    }\r\n\r\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n\r\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\r\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\r\n\r\n    // Internal function version of diamondCut\r\n    // This code is almost the same as the external diamondCut,\r\n    // except it is using 'Facet[] memory _diamondCut' instead of\r\n    // 'Facet[] calldata _diamondCut'.\r\n    // The code is duplicated to prevent copying calldata to memory which\r\n    // causes an error for a two dimensional array.\r\n    function diamondCut(\r\n        IDiamondCut.FacetCut[] memory _diamondCut,\r\n        address _init,\r\n        bytes memory _calldata\r\n    ) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        uint256 originalSelectorCount = ds.selectorCount;\r\n        uint256 selectorCount = originalSelectorCount;\r\n        bytes32 selectorSlot;\r\n        // Check if last selector slot is not full\r\n        if (selectorCount & 7 > 0) {\r\n            // get last selectorSlot\r\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\r\n        }\r\n        // loop through diamond cut\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\r\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\r\n                selectorCount,\r\n                selectorSlot,\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n        }\r\n        if (selectorCount != originalSelectorCount) {\r\n            ds.selectorCount = uint16(selectorCount);\r\n        }\r\n        // If last selector slot is not full\r\n        if (selectorCount & 7 > 0) {\r\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        initializeDiamondCut(_init, _calldata);\r\n    }\r\n\r\n    function addReplaceRemoveFacetSelectors(\r\n        uint256 _selectorCount,\r\n        bytes32 _selectorSlot,\r\n        address _newFacetAddress,\r\n        IDiamondCut.FacetCutAction _action,\r\n        bytes4[] memory _selectors\r\n    ) internal returns (uint256, bytes32) {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        if (_action == IDiamondCut.FacetCutAction.Add) {\r\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];\r\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\r\n                // add facet for selector\r\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\r\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\r\n                // clear selector position in slot and add selector\r\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\r\n                // if slot is full then write it to storage\r\n                if (selectorInSlotPosition == 224) {\r\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\r\n                    _selectorSlot = 0;\r\n                }\r\n                _selectorCount++;\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\r\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];\r\n                address oldFacetAddress = address(bytes20(oldFacet));\r\n                // only useful if immutable functions exist\r\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\r\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\r\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\r\n                // replace old facet address\r\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\r\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\r\n            uint256 selectorSlotCount = _selectorCount >> 3;\r\n            uint256 selectorInSlotIndex = _selectorCount & 7;\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                if (_selectorSlot == 0) {\r\n                    // get last selectorSlot\r\n                    selectorSlotCount--;\r\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\r\n                    selectorInSlotIndex = 7;\r\n                } else {\r\n                    selectorInSlotIndex--;\r\n                }\r\n                bytes4 lastSelector;\r\n                uint256 oldSelectorsSlotCount;\r\n                uint256 oldSelectorInSlotPosition;\r\n                // adding a block here prevents stack too deep error\r\n                {\r\n                    bytes4 selector = _selectors[selectorIndex];\r\n                    bytes32 oldFacet = ds.facets[selector];\r\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\r\n                    // only useful if immutable functions exist\r\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\r\n                    // replace selector with last selector in ds.facets\r\n                    // gets the last selector\r\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\r\n                    if (lastSelector != selector) {\r\n                        // update last selector slot position info\r\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\r\n                    }\r\n                    delete ds.facets[selector];\r\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\r\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\r\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\r\n                }\r\n                if (oldSelectorsSlotCount != selectorSlotCount) {\r\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    oldSelectorSlot =\r\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                    // update storage with the modified slot\r\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\r\n                } else {\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    _selectorSlot =\r\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                }\r\n                if (selectorInSlotIndex == 0) {\r\n                    delete ds.selectorSlots[selectorSlotCount];\r\n                    _selectorSlot = 0;\r\n                }\r\n            }\r\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\r\n        } else {\r\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\r\n        }\r\n        return (_selectorCount, _selectorSlot);\r\n    }\r\n\r\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\r\n        if (_init == address(0)) {\r\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\r\n        } else {\r\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\r\n            if (_init != address(this)) {\r\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\r\n            }\r\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\r\n            if (!success) {\r\n                if (error.length > 0) {\r\n                    // bubble up the error\r\n                    revert(string(error));\r\n                } else {\r\n                    revert(\"LibDiamondCut: _init function reverted\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        require(contractSize > 0, _errorMessage);\r\n    }\r\n}"
    },
    "contracts/libraries/LibSignature.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nlibrary LibSignature {\r\n\r\n    function isValid(bytes32 messageHash, bytes memory signature, bytes memory pubKey) internal pure returns (bool) {\r\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\r\n\r\n        return recoverSigner(ethSignedMessageHash, signature) == address(uint160(uint256(keccak256(pubKey))));\r\n    }\r\n\r\n    function getEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash));\r\n    }\r\n\r\n    function recoverSigner(bytes32 ethSignedMessageHash, bytes memory signature) internal pure returns (address)\r\n    {\r\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);\r\n\r\n        return ecrecover(ethSignedMessageHash, v, r, s);\r\n    }\r\n\r\n    function splitSignature(bytes memory sig) internal pure returns (bytes32 r, bytes32 s, uint8 v)\r\n    {\r\n        require(sig.length == 65, \"Invalid signature length\");\r\n\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n        // implicitly return (r, s, v)\r\n    }\r\n}"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n    // Add=0, Replace=1, Remove=2\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}